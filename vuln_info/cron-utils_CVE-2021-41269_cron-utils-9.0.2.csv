Vul_Path,Vul_Src
"src/main/java/com/cronutils/parser/CronParser.java:[37,135]:CronParser","public class CronParser {

    private final Map<Integer, List<CronParserField>> expressions = new HashMap<>();
    private final CronDefinition cronDefinition;

    /**
     * @param cronDefinition - cronDefinition of cron expressions to be parsed if null, a NullPointerException will be raised.
     */
    public CronParser(final CronDefinition cronDefinition) {
        this.cronDefinition = Preconditions.checkNotNull(cronDefinition, ""CronDefinition must not be null"");
        buildPossibleExpressions(cronDefinition);
    }

    /**
     * Build possible cron expressions from definitions. One is built for sure. A second one may be build if last field is optional.
     *
     * @param cronDefinition - cron definition instance
     */
    private void buildPossibleExpressions(final CronDefinition cronDefinition) {
        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()
                .map(this::toCronParserField)
                .sorted(CronParserField.createFieldTypeComparator())
                .collect(Collectors.toList());

        List<CronParserField> tempExpression = sortedExpression;

        while(lastFieldIsOptional(tempExpression)) {
            int expressionLength = tempExpression.size() - 1;
            ArrayList<CronParserField> possibleExpression = new ArrayList<>(tempExpression.subList(0, expressionLength));

            expressions.put(expressionLength, possibleExpression);
            tempExpression = possibleExpression;
        }

        expressions.put(sortedExpression.size(), sortedExpression);
    }

    private CronParserField toCronParserField(final FieldDefinition fieldDefinition) {
        return new CronParserField(fieldDefinition.getFieldName(), fieldDefinition.getConstraints(), fieldDefinition.isOptional());
    }

    private boolean lastFieldIsOptional(final List<CronParserField> fields) {
        return !fields.isEmpty() && fields.get(fields.size() - 1).isOptional();
    }

    /**
     * Parse string with cron expression.
     *
     * @param expression - cron expression, never null
     * @return Cron instance, corresponding to cron expression received
     * @throws java.lang.IllegalArgumentException if expression does not match cron definition
     */
    public Cron parse(final String expression) {
        Preconditions.checkNotNull(expression, ""Expression must not be null"");
        final String replaced = expression.replaceAll(""\\s+"", "" "").trim();
        if (StringUtils.isEmpty(replaced)) {
            throw new IllegalArgumentException(""Empty expression!"");
        }

        if(expression.contains(""|"")){
            List<String> crons = new ArrayList<>();
            int cronscount = Arrays.stream(expression.split(""\\s+"")).mapToInt(s->s.split(""\\|"").length).max().orElse(0);
            for(int j=0; j<cronscount; j++){
                StringBuilder builder = new StringBuilder();
                for(String s : expression.split(""\\s+"")){
                    if(s.contains(""|"")){
                        builder.append(String.format(""%s "", s.split(""\\|"")[j]));
                    }else{
                        builder.append(String.format(""%s "", s));
                    }
                }
                crons.add(builder.toString().trim());
            }
            return new CompositeCron(crons.stream().map(c->parse(c)).collect(Collectors.toList()));
        }else{
            final String[] expressionParts = replaced.toUpperCase().split("" "");
            final int expressionLength = expressionParts.length;
            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith("","")).findAny().orElse(null);
            if(fieldWithTrailingCommas!=null){
                throw new IllegalArgumentException(String.format(""Invalid field value! Trailing commas not permitted! '%s'"", fieldWithTrailingCommas));
            }
            final List<CronParserField> fields = expressions.get(expressionLength);
            if (fields == null) {
                throw new IllegalArgumentException(
                        String.format(""Cron expression contains %s parts but we expect one of %s"", expressionLength, expressions.keySet()));
            }
            try {
                final int size = fields.size();
                final List<CronField> results = new ArrayList<>(size + 1);
                for (int j = 0; j < size; j++) {
                    results.add(fields.get(j).parse(expressionParts[j]));
                }
                return new SingleCron(cronDefinition, results).validate();
            } catch (final IllegalArgumentException e) {
                throw new IllegalArgumentException(String.format(""Failed to parse '%s'. %s"", expression, e.getMessage()), e);
            }
        }
    }
}
"
"src/main/java/com/cronutils/parser/CronParser.java:[89,134]:parse","    public Cron parse(final String expression) {
        Preconditions.checkNotNull(expression, ""Expression must not be null"");
        final String replaced = expression.replaceAll(""\\s+"", "" "").trim();
        if (StringUtils.isEmpty(replaced)) {
            throw new IllegalArgumentException(""Empty expression!"");
        }

        if(expression.contains(""|"")){
            List<String> crons = new ArrayList<>();
            int cronscount = Arrays.stream(expression.split(""\\s+"")).mapToInt(s->s.split(""\\|"").length).max().orElse(0);
            for(int j=0; j<cronscount; j++){
                StringBuilder builder = new StringBuilder();
                for(String s : expression.split(""\\s+"")){
                    if(s.contains(""|"")){
                        builder.append(String.format(""%s "", s.split(""\\|"")[j]));
                    }else{
                        builder.append(String.format(""%s "", s));
                    }
                }
                crons.add(builder.toString().trim());
            }
            return new CompositeCron(crons.stream().map(c->parse(c)).collect(Collectors.toList()));
        }else{
            final String[] expressionParts = replaced.toUpperCase().split("" "");
            final int expressionLength = expressionParts.length;
            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith("","")).findAny().orElse(null);
            if(fieldWithTrailingCommas!=null){
                throw new IllegalArgumentException(String.format(""Invalid field value! Trailing commas not permitted! '%s'"", fieldWithTrailingCommas));
            }
            final List<CronParserField> fields = expressions.get(expressionLength);
            if (fields == null) {
                throw new IllegalArgumentException(
                        String.format(""Cron expression contains %s parts but we expect one of %s"", expressionLength, expressions.keySet()));
            }
            try {
                final int size = fields.size();
                final List<CronField> results = new ArrayList<>(size + 1);
                for (int j = 0; j < size; j++) {
                    results.add(fields.get(j).parse(expressionParts[j]));
                }
                return new SingleCron(cronDefinition, results).validate();
            } catch (final IllegalArgumentException e) {
                throw new IllegalArgumentException(String.format(""Failed to parse '%s'. %s"", expression, e.getMessage()), e);
            }
        }
    }
"
"src/test/java/com/cronutils/validation/CronValidatorTest.java:[17,70]:CronValidatorTest","public class CronValidatorTest {

    private final Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

    private final String expression;
    private final boolean valid;

    public CronValidatorTest(String expression, boolean valid) {
        this.expression = expression;
        this.valid = valid;
    }

    @Parameterized.Parameters(name = ""{0} "")
    public static Object[] expressions() {
        return new Object[][]{
                {""0 0 * * * *"", true},
                {""*/10 * * * * *"", true},
                {""0 0 8-10 * * *"", true},
                {""0 0 6,19 * * *"", true},
                {""0 0/30 8-10 * * *"", true},
                {""0 0 9-17 * * MON-FRI"", true},
                {""0 0 0 25 12 ?"", true},
                {""0 0 0 L 12 ?"", false},
                {""1,2, * * * * *"", false},
                {""1- * * * * *"", false}
        };
    }

    @Test
    public void validateExamples() {
        TestPojo testPojo = new TestPojo(expression);
        Set<ConstraintViolation<TestPojo>> violations = validator.validate(testPojo);

        if (valid) {
            assertTrue(violations.isEmpty());
        } else {
            assertFalse(violations.isEmpty());
        }
    }

    public static class TestPojo {
        @Cron(type = CronType.SPRING)
        private final String cron;

        public TestPojo(String cron) {
            this.cron = cron;
        }

        public String getCron() {
            return cron;
        }

    }
}"
"src/test/java/com/cronutils/validation/CronValidatorTest.java:[30,43]:expressions","    public static Object[] expressions() {
        return new Object[][]{
                {""0 0 * * * *"", true},
                {""*/10 * * * * *"", true},
                {""0 0 8-10 * * *"", true},
                {""0 0 6,19 * * *"", true},
                {""0 0/30 8-10 * * *"", true},
                {""0 0 9-17 * * MON-FRI"", true},
                {""0 0 0 25 12 ?"", true},
                {""0 0 0 L 12 ?"", false},
                {""1,2, * * * * *"", false},
                {""1- * * * * *"", false}
        };
    }
"
"src/test/java/com/cronutils/validation/CronValidatorTest.java:[46,55]:validateExamples","    public void validateExamples() {
        TestPojo testPojo = new TestPojo(expression);
        Set<ConstraintViolation<TestPojo>> violations = validator.validate(testPojo);

        if (valid) {
            assertTrue(violations.isEmpty());
        } else {
            assertFalse(violations.isEmpty());
        }
    }
"
"src/test/java/com/cronutils/parser/CronParserQuartzIntegrationTest.java:[37,341]:CronParserQuartzIntegrationTest","public class CronParserQuartzIntegrationTest {

    private static final String LAST_EXECUTION_NOT_PRESENT_ERROR = ""last execution was not present"";
    private CronParser parser;

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Before
    public void setUp() {
        parser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));
    }

    /**
     * Corresponds to issue#11
     * https://github.com/jmrozanec/cron-utils/issues/11
     * Reported case:
     * when parsing: ""* * * * $ ?""
     * we receive: NumberFormatException
     * Expected: throw IllegalArgumentException notifying invalid char was used
     */
    @Test(expected = IllegalArgumentException.class)
    public void testInvalidCharsDetected() {
        parser.parse(""* * * * $ ?"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidCharsDetectedWithSingleSpecialChar() {
        parser.parse(""* * * * $W ?"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidCharsDetectedWithHashExpression1() {
        parser.parse(""* * * * $#3 ?"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidCharsDetectedWithHashExpression2() {
        parser.parse(""* * * * 3#$ ?"");
    }

    /**
     * Issue #15: we should support L in range (ex.: L-3)
     */
    @Test
    public void testLSupportedInDoMRange() {
        parser.parse(""* * * L-3 * ?"");
    }

    /**
     * Issue #15: we should support L in range (ex.: L-3), but not other special chars
     */
    @Test(expected = IllegalArgumentException.class)
    public void testLSupportedInRange() {
        parser.parse(""* * * W-3 * ?"");
    }

    @Test
    public void testNLSupported() {
        parser.parse(""* * * 3L * ?"");
    }

    /**
     * Issue #23: we should support L in DoM.
     */
    @Test
    public void testLSupportedInDoM() {
        parser.parse(""0 0/10 22 L * ?"");
    }

    /**
     * Issue #27: month ranges string mapping.
     */
    @Test
    public void testMonthRangeStringMapping() {
        parser.parse(""0 0 0 * JUL-AUG ? *"");
        parser.parse(""0 0 0 * JAN-FEB ? *"");
    }

    /**
     * Issue #27: month string mapping.
     */
    @Test
    public void testSingleMonthStringMapping() {
        parser.parse(""0 0 0 * JAN ? *"");
    }

    /**
     * Issue #27: day of week string ranges mapping.
     */
    @Test
    public void testDoWRangeStringMapping() {
        parser.parse(""0 0 0 ? * MON-FRI *"");
    }

    /**
     * Issue #27: day of week string mapping.
     */
    @Test
    public void testSingleDoWStringMapping() {
        parser.parse(""0 0 0 ? * MON *"");
    }

    /**
     * Issue #27: July month as string is parsed as some special char occurrence.
     */
    @Test
    public void testJulyMonthAsStringConsideredSpecialChar() {
        assertNotNull(parser.parse(""0 0 0 * JUL ? *""));
    }

    /**
     * Issue #35: A>B in range considered invalid expression for Quartz.
     */
    @Test
    public void testSunToSat() {
        // FAILS SUN-SAT: SUN = 7 and SAT = 6
        parser.parse(""0 0 12 ? * SUN-SAT"");
    }

    /**
     * Issue #39: reported issue about exception being raised on parse.
     */
    @Test
    public void testParseExpressionWithQuestionMarkAndWeekdays() {
        parser.parse(""0 0 0 ? * MON,TUE *"");
    }

    /**
     * Issue #39: reported issue about exception being raised on parse.
     */
    @Test
    public void testDescribeExpressionWithQuestionMarkAndWeekdays() {
        final Cron quartzCron = parser.parse(""0 0 0 ? * MON,TUE *"");
        final CronDescriptor descriptor = CronDescriptor.instance(Locale.ENGLISH);
        descriptor.describe(quartzCron);
    }

    /**
     * Issue #60: Parser exception when parsing cron.
     */
    @Test
    public void testDescribeExpression() {
        final String expression = ""0 * * ? * 1,5"";
        final Cron c = parser.parse(expression);
        CronDescriptor.instance(Locale.GERMAN).describe(c);
    }

    /**
     * Issue #63: Parser exception when parsing cron.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testDoMAndDoWParametersInvalidForQuartz() {
        parser.parse(""0 30 17 4 1 * 2016"");
    }

    /**
     * Issue #78: ExecutionTime.forCron fails on intervals
     */
    @Test
    public void testIntervalSeconds() {
        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(""0/20 * * * * ?""));
        final ZonedDateTime now = ZonedDateTime.parse(""2005-08-09T18:32:42Z"");
        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);
        if (lastExecution.isPresent()) {
            final ZonedDateTime assertDate = ZonedDateTime.parse(""2005-08-09T18:32:40Z"");
            assertEquals(assertDate, lastExecution.get());
        } else {
            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);
        }
    }

    /**
     * Issue #78: ExecutionTime.forCron fails on intervals
     */
    @Test
    public void testIntervalMinutes() {
        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(""0 0/7 * * * ?""));
        final ZonedDateTime now = ZonedDateTime.parse(""2005-08-09T18:32:42Z"");
        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);
        if (lastExecution.isPresent()) {
            final ZonedDateTime assertDate = ZonedDateTime.parse(""2005-08-09T18:28:00Z"");
            assertEquals(assertDate, lastExecution.get());
        } else {
            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);
        }
    }

    /**
     * Issue #89: regression - NumberFormatException: For input string: ""$"".
     */
    @Test
    public void testRegressionDifferentMessageForException() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage(""Invalid chars in expression! Expression: $ Invalid chars: $"");
        assertNotNull(ExecutionTime.forCron(parser.parse(""* * * * $ ?"")));
    }

    /**
     * Issue #90: Reported error contains other expression than the one provided.
     */
    @Test
    public void testReportedErrorContainsSameExpressionAsProvided() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage(
                ""Invalid cron expression: 0/1 * * * * *. Both, a day-of-week AND a day-of-month parameter, are not supported."");
        assertNotNull(ExecutionTime.forCron(parser.parse(""0/1 * * * * *"")));
    }

    /**
     * Issue #109: Missing expression and invalid chars in error message
     * https://github.com/jmrozanec/cron-utils/issues/109
     */
    @Test
    public void testMissingExpressionAndInvalidCharsInErrorMessage() {
        thrown.expect(IllegalArgumentException.class);
        final String cronexpression = ""* * -1 * * ?"";
        thrown.expectMessage(
                String.format(""Failed to parse '%s'. Invalid expression! Expression: -1 does not describe a range. Negative numbers are not allowed."",
                        cronexpression));
        assertNotNull(ExecutionTime.forCron(parser.parse(cronexpression)));
    }

    /**
     * Issue #148: Cron Builder/Parser fails on Every X years.
     */
    @Test
    public void testEveryXYears() {
        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withDoM(FieldExpressionFactory.on(1))
                .withDoW(FieldExpressionFactory.questionMark())
                .withYear(FieldExpressionFactory.every(FieldExpressionFactory.between(1970, 2099), 4))
                .withMonth(FieldExpressionFactory.on(1))
                .withHour(FieldExpressionFactory.on(0))
                .withMinute(FieldExpressionFactory.on(0))
                .withSecond(FieldExpressionFactory.on(0));
    }

    @Test
    public void testRejectIllegalMonthArgument() {
        thrown.expect(IllegalArgumentException.class);
        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withMonth(FieldExpressionFactory.on(0));
    }

    /**
     * Issue #151: L-7 in day of month should work to find the day 7 days prior to the last day of the month.
     */
    @Test
    public void testLSupportedInDoMRangeNextExecutionCalculation() {
        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(""0 15 10 L-7 * ?""));
        final ZonedDateTime now = ZonedDateTime.parse(""2017-01-31T10:00:00Z"");
        final Optional<ZonedDateTime> nextExecution = executionTime.nextExecution(now);
        if (nextExecution.isPresent()) {
            final ZonedDateTime assertDate = ZonedDateTime.parse(""2017-02-21T10:15:00Z"");
            assertEquals(assertDate, nextExecution.get());
        } else {
            fail(""next execution was not present"");
        }
    }

    /**
     * Issue #154: Quartz Cron Year Pattern is not fully supported - i.e. increments on years are not supported
     * https://github.com/jmrozanec/cron-utils/issues/154
     * Duplicate of #148
     */
    @Test
    public void supportQuartzCronExpressionIncrementsOnYears() {
        final String[] sampleCronExpressions = {
                ""0 0 0 1 * ? 2017/2"",
                ""0 0 0 1 * ? 2017/3"",
                ""0 0 0 1 * ? 2017/10"",
                ""0 0 0 1 * ? 2017-2047/2"",
        };

        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));
        for (final String cronExpression : sampleCronExpressions) {
            final Cron quartzCron = quartzCronParser.parse(cronExpression);
            quartzCron.validate();
        }
    }

    @Test
    public void testErrorAbout2Parts() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage(""Cron expression contains 2 parts but we expect one of [6, 7]"");
        assertNotNull(ExecutionTime.forCron(parser.parse(""* *"")));
    }

    @Test
    public void testErrorAboutMissingSteps() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage(""Missing steps for expression: */"");
        assertNotNull(ExecutionTime.forCron(parser.parse(""*/ * * * * ?"")));
    }

    /**
     * Issue #375: Quartz Last Day of Week pattern does not support Day of Week as text
     * https://github.com/jmrozanec/cron-utils/issues/375
     */
    @Test
    public void testLastDayOfWeek() {
        final String cronExpression = ""0 0 1 ? 1/1 MONL *"";
        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));
        quartzCronParser.parse(cronExpression);
    }
}
"
"src/test/java/com/cronutils/parser/CronParserQuartzIntegrationTest.java:[251,258]:testMissingExpressionAndInvalidCharsInErrorMessage","    public void testMissingExpressionAndInvalidCharsInErrorMessage() {
        thrown.expect(IllegalArgumentException.class);
        final String cronexpression = ""* * -1 * * ?"";
        thrown.expectMessage(
                String.format(""Failed to parse '%s'. Invalid expression! Expression: -1 does not describe a range. Negative numbers are not allowed."",
                        cronexpression));
        assertNotNull(ExecutionTime.forCron(parser.parse(cronexpression)));
    }
"
"src/main/java/com/cronutils/validation/CronValidator.java:[21,36]:isValid","    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }

        CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(type);
        CronParser cronParser = new CronParser(cronDefinition);
        try {
            cronParser.parse(value).validate();
            return true;
        } catch (IllegalArgumentException e) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(e.getMessage()).addConstraintViolation();
            return false;
        }
    }
"
