Vul_Path,Vul_Src
"core/src/main/java/io/undertow/server/protocol/http/ParseState.java:[113,113]:headerValuesCache","    final HashMap<HttpString, String> headerValuesCache = new HashMap<>();
"
"core/src/main/java/io/undertow/server/protocol/http/ParseState.java:[39,141]:ParseState","class ParseState {

    //parsing states
    public static final int VERB = 0;
    public static final int PATH = 1;
    public static final int PATH_PARAMETERS = 2;
    public static final int QUERY_PARAMETERS = 3;
    public static final int VERSION = 4;
    public static final int AFTER_VERSION = 5;
    public static final int HEADER = 6;
    public static final int HEADER_VALUE = 7;
    public static final int PARSE_COMPLETE = 8;

    /**
     * The actual state of request parsing
     */
    int state;

    /**
     * The current state in the tokenizer state machine.
     */
    int parseState;

    /**
     * If this state is a prefix or terminal match state this is set to the string
     * that is a candidate to be matched
     */
    HttpString current;

    /**
     * The bytes version of {@link #current}
     */
    byte[] currentBytes;

    /**
     * If this state is a prefix match state then this holds the current position in the string.
     *
     */
    int pos;

    boolean urlDecodeRequired = false;

    /**
     * If this is in {@link io.undertow.annotationprocessor.AbstractParserGenerator#NO_STATE} then this holds the current token that has been read so far.
     */
    final StringBuilder stringBuilder = new StringBuilder();

    /**
     * This has different meanings depending on the current state.
     *
     * In state {@link #HEADER} it is a the first character of the header, that was read by
     * {@link #HEADER_VALUE} to see if this was a continuation.
     *
     * In state {@link #HEADER_VALUE} if represents the last character that was seen.
     *
     */
    byte leftOver;


    /**
     * This is used to store the next header value when parsing header key / value pairs,
     */
    HttpString nextHeader;

    String nextQueryParam;

    int mapCount;

    final StringBuilder decodeBuffer = new StringBuilder();

    /**
     * In general browsers will often send the same header with every request. This cache allows us to re-use the resulting
     * strings.
     */
    final HashMap<HttpString, String> headerValuesCache = new HashMap<>();

    ParseState() {
        this.parseState = 0;
        this.pos = 0;
    }

    public boolean isComplete() {
        return state == PARSE_COMPLETE;
    }

    public final void parseComplete(){
        state = PARSE_COMPLETE;
    }

    public void reset() {
        this.state = 0;
        this.parseState = 0;
        this.current = null;
        this.currentBytes = null;
        this.pos = 0;
        this.leftOver = 0;
        this.urlDecodeRequired = false;
        this.stringBuilder.setLength(0);
        this.nextHeader = null;
        this.nextQueryParam = null;
        this.mapCount = 0;
    }
}
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[44,287]:SimpleParserTestCase","public class SimpleParserTestCase {

    private final ParseState parseState = new ParseState();

    @Test
    public void testEncodedSlashDisallowed() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath%2FotherPath HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath%2FotherPath"", result.getRequestURI());
        Assert.assertEquals(""/somepath%2FotherPath"", result.getRequestPath());
    }

    @Test
    public void testEncodedSlashAllowed() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath%2fotherPath HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath/otherPath"", result.getRequestPath());
        Assert.assertEquals(""/somepath%2fotherPath"", result.getRequestURI());
    }

    @Test
    public void testColonSlashInURL() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestPath());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestURI());
    }

    @Test
    public void testColonSlashInFullURL() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET http://foo.com/a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestPath());
        Assert.assertEquals(""http://foo.com/a/http://myurl.com/b/c"", result.getRequestURI());
    }


    @Test
    public void testPathParameters() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath;p1 HTTP/1.1\r\n\r\n"".getBytes();
        ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath"", result.getRequestPath());
        Assert.assertEquals(""/somepath;p1"", result.getRequestURI());
        Assert.assertTrue(result.getPathParameters().containsKey(""p1""));

        in = ""GET /somepath;p1=v1&p2=v2?q1=v3 HTTP/1.1\r\n\r\n"".getBytes();
        context = new ParseState();
        result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath"", result.getRequestPath());
        Assert.assertEquals(""/somepath;p1=v1&p2=v2"", result.getRequestURI());
        Assert.assertEquals(""q1=v3"", result.getQueryString());
        Assert.assertEquals(""v1"", result.getPathParameters().get(""p1"").getFirst());
        Assert.assertEquals(""v2"", result.getPathParameters().get(""p2"").getFirst());
        Assert.assertEquals(""v3"", result.getQueryParameters().get(""q1"").getFirst());
    }

    @Test
    public void testFullUrlRootPath() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET http://myurl.com HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/"", result.getRequestPath());
        Assert.assertEquals(""http://myurl.com"", result.getRequestURI());
    }
    @Test
    public void testSimpleRequest() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\n\r\n"".getBytes();
        runTest(in);
    }



    @Test
    public void testSimpleRequestWithHeaderCaching() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: foo\r\n\r\n"".getBytes();
        runTest(in, ""foo"");
        in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader:       foo\r\n\r\n"".getBytes();
        runTest(in, ""foo"");
        in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader:      some value\r\n\r\n"".getBytes();
        runTest(in);
        in = ""GET /somepath HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some value\r\n\r\n"".getBytes();
        runTest(in);
    }


    @Test
    public void testCarriageReturnLineEnds() throws HttpRequestParser.BadRequestException {

        byte[] in = ""GET /somepath HTTP/1.1\rHost:   www.somehost.net\rOtherHeader: some\r    value\r\r\n"".getBytes();
        runTest(in);
    }

    @Test
    public void testLineFeedsLineEnds() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath HTTP/1.1\nHost:   www.somehost.net\nOtherHeader: some\n    value\n\n"".getBytes();
        runTest(in);
    }

    @Test
    public void testTabWhitespace() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\t/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();
        runTest(in);
    }

    @Test
    public void testCanonicalPath() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertEquals(""/somepath"", result.getRelativePath());
        Assert.assertEquals(""http://www.somehost.net/somepath"", result.getRequestURI());
    }

    @Test
    public void testNoHeaders() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\t/aa\tHTTP/1.1\n\n\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertTrue(context.isComplete());
        Assert.assertEquals(""/aa"", result.getRelativePath());
    }

    @Test
    public void testQueryParams() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath?a=b&b=c&d&e&f=\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertEquals(""/somepath"", result.getRelativePath());
        Assert.assertEquals(""http://www.somehost.net/somepath"", result.getRequestURI());
        Assert.assertEquals(""a=b&b=c&d&e&f="", result.getQueryString());
        Assert.assertEquals(""b"", result.getQueryParameters().get(""a"").getFirst());
        Assert.assertEquals(""c"", result.getQueryParameters().get(""b"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""d"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""e"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""f"").getFirst());

    }

    @Test
    public void testSameHttpStringReturned() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nAccept-Charset:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context1 = new ParseState();
        HttpServerExchange result1 = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context1, result1);

        final ParseState context2 = new ParseState();
        HttpServerExchange result2 = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context2, result2);

        Assert.assertSame(result1.getProtocol(), result2.getProtocol());
        Assert.assertSame(result1.getRequestMethod(), result2.getRequestMethod());

        for (final HttpString header : result1.getRequestHeaders().getHeaderNames()) {
            boolean found = false;
            for (final HttpString header2 : result1.getRequestHeaders().getHeaderNames()) {
                if (header == header2) {
                    found = true;
                    break;
                }
            }
            if (header.equals(Headers.HOST)) {
                Assert.assertSame(Headers.HOST, header);
            }
            Assert.assertTrue(""Could not found header "" + header, found);
        }
    }


    @Test
    public void testEmptyQueryParams() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /clusterbench/requestinfo//?;?=44&test=OK;devil=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&777=666 HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/clusterbench/requestinfo//"", result.getRequestURI());
        Assert.assertEquals(""/clusterbench/requestinfo//"", result.getRequestPath());
        Assert.assertEquals(3, result.getQueryParameters().size());
        Assert.assertEquals(""OK;devil=3"", result.getQueryParameters().get(""test"").getFirst());
        Assert.assertEquals(""666"", result.getQueryParameters().get(""777"").getFirst());
        Assert.assertEquals(""44"", result.getQueryParameters().get("";?"").getFirst());
    }
    @Test
    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException, HttpRequestParser.BadRequestException {
        byte[] in = ""GET /bÃÂ¥r HTTP/1.1\r\n\r\n"".getBytes(""ISO-8859-1"");

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/bÃ¥r"", result.getRequestPath());
        Assert.assertEquals(""/bÃÂ¥r"", result.getRequestURI()); //not decoded
    }

    private void runTest(final byte[] in) throws HttpRequestParser.BadRequestException {
        runTest(in, ""some value"");
    }
    private void runTest(final byte[] in, String lastHeader) throws HttpRequestParser.BadRequestException {
        parseState.reset();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), parseState, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath"", result.getRequestURI());
        Assert.assertSame(Protocols.HTTP_1_1, result.getProtocol());

        Assert.assertEquals(2, result.getRequestHeaders().getHeaderNames().size());
        Assert.assertEquals(""www.somehost.net"", result.getRequestHeaders().getFirst(new HttpString(""Host"")));
        Assert.assertEquals(lastHeader, result.getRequestHeaders().getFirst(new HttpString(""OtherHeader"")));

        Assert.assertEquals(ParseState.PARSE_COMPLETE, parseState.state);
    }
}
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[46,46]:parseState","    private final ParseState parseState = new ParseState();
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[49,58]:testEncodedSlashDisallowed","    public void testEncodedSlashDisallowed() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath%2FotherPath HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath%2FotherPath"", result.getRequestURI());
        Assert.assertEquals(""/somepath%2FotherPath"", result.getRequestPath());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[61,70]:testEncodedSlashAllowed","    public void testEncodedSlashAllowed() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath%2fotherPath HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath/otherPath"", result.getRequestPath());
        Assert.assertEquals(""/somepath%2fotherPath"", result.getRequestURI());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[73,82]:testColonSlashInURL","    public void testColonSlashInURL() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestPath());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestURI());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[85,94]:testColonSlashInFullURL","    public void testColonSlashInFullURL() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET http://foo.com/a/http://myurl.com/b/c HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/a/http://myurl.com/b/c"", result.getRequestPath());
        Assert.assertEquals(""http://foo.com/a/http://myurl.com/b/c"", result.getRequestURI());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[98,119]:testPathParameters","    public void testPathParameters() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /somepath;p1 HTTP/1.1\r\n\r\n"".getBytes();
        ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath"", result.getRequestPath());
        Assert.assertEquals(""/somepath;p1"", result.getRequestURI());
        Assert.assertTrue(result.getPathParameters().containsKey(""p1""));

        in = ""GET /somepath;p1=v1&p2=v2?q1=v3 HTTP/1.1\r\n\r\n"".getBytes();
        context = new ParseState();
        result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/somepath"", result.getRequestPath());
        Assert.assertEquals(""/somepath;p1=v1&p2=v2"", result.getRequestURI());
        Assert.assertEquals(""q1=v3"", result.getQueryString());
        Assert.assertEquals(""v1"", result.getPathParameters().get(""p1"").getFirst());
        Assert.assertEquals(""v2"", result.getPathParameters().get(""p2"").getFirst());
        Assert.assertEquals(""v3"", result.getQueryParameters().get(""q1"").getFirst());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[122,131]:testFullUrlRootPath","    public void testFullUrlRootPath() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET http://myurl.com HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true)).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/"", result.getRequestPath());
        Assert.assertEquals(""http://myurl.com"", result.getRequestURI());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[173,181]:testCanonicalPath","    public void testCanonicalPath() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertEquals(""/somepath"", result.getRelativePath());
        Assert.assertEquals(""http://www.somehost.net/somepath"", result.getRequestURI());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[184,192]:testNoHeaders","    public void testNoHeaders() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\t/aa\tHTTP/1.1\n\n\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertTrue(context.isComplete());
        Assert.assertEquals(""/aa"", result.getRelativePath());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[195,210]:testQueryParams","    public void testQueryParams() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath?a=b&b=c&d&e&f=\tHTTP/1.1\nHost: \t www.somehost.net\nOtherHeader:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertEquals(""/somepath"", result.getRelativePath());
        Assert.assertEquals(""http://www.somehost.net/somepath"", result.getRequestURI());
        Assert.assertEquals(""a=b&b=c&d&e&f="", result.getQueryString());
        Assert.assertEquals(""b"", result.getQueryParameters().get(""a"").getFirst());
        Assert.assertEquals(""c"", result.getQueryParameters().get(""b"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""d"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""e"").getFirst());
        Assert.assertEquals("""", result.getQueryParameters().get(""f"").getFirst());

    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[213,240]:testSameHttpStringReturned","    public void testSameHttpStringReturned() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET\thttp://www.somehost.net/somepath\tHTTP/1.1\nHost: \t www.somehost.net\nAccept-Charset:\tsome\n \t  value\n\r\n"".getBytes();

        final ParseState context1 = new ParseState();
        HttpServerExchange result1 = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context1, result1);

        final ParseState context2 = new ParseState();
        HttpServerExchange result2 = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context2, result2);

        Assert.assertSame(result1.getProtocol(), result2.getProtocol());
        Assert.assertSame(result1.getRequestMethod(), result2.getRequestMethod());

        for (final HttpString header : result1.getRequestHeaders().getHeaderNames()) {
            boolean found = false;
            for (final HttpString header2 : result1.getRequestHeaders().getHeaderNames()) {
                if (header == header2) {
                    found = true;
                    break;
                }
            }
            if (header.equals(Headers.HOST)) {
                Assert.assertSame(Headers.HOST, header);
            }
            Assert.assertTrue(""Could not found header "" + header, found);
        }
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[244,257]:testEmptyQueryParams","    public void testEmptyQueryParams() throws HttpRequestParser.BadRequestException {
        byte[] in = ""GET /clusterbench/requestinfo//?;?=44&test=OK;devil=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&777=666 HTTP/1.1\r\n\r\n"".getBytes();

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/clusterbench/requestinfo//"", result.getRequestURI());
        Assert.assertEquals(""/clusterbench/requestinfo//"", result.getRequestPath());
        Assert.assertEquals(3, result.getQueryParameters().size());
        Assert.assertEquals(""OK;devil=3"", result.getQueryParameters().get(""test"").getFirst());
        Assert.assertEquals(""666"", result.getQueryParameters().get(""777"").getFirst());
        Assert.assertEquals(""44"", result.getQueryParameters().get("";?"").getFirst());
    }
"
"core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java:[259,268]:testNonEncodedAsciiCharacters","    public void testNonEncodedAsciiCharacters() throws UnsupportedEncodingException, HttpRequestParser.BadRequestException {
        byte[] in = ""GET /bÃÂ¥r HTTP/1.1\r\n\r\n"".getBytes(""ISO-8859-1"");

        final ParseState context = new ParseState();
        HttpServerExchange result = new HttpServerExchange(null);
        HttpRequestParser.instance(OptionMap.EMPTY).handle(ByteBuffer.wrap(in), context, result);
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/bÃ¥r"", result.getRequestPath());
        Assert.assertEquals(""/bÃÂ¥r"", result.getRequestURI()); //not decoded
    }
"
"core/src/main/java/io/undertow/UndertowMessages.java:[42,506]:UndertowMessages","public interface UndertowMessages {

    UndertowMessages MESSAGES = Messages.getBundle(UndertowMessages.class);

    @Message(id = 1, value = ""Maximum concurrent requests must be larger than zero."")
    IllegalArgumentException maximumConcurrentRequestsMustBeLargerThanZero();

    @Message(id = 2, value = ""The response has already been started"")
    IllegalStateException responseAlreadyStarted();

    // id = 3

    @Message(id = 4, value = ""getResponseChannel() has already been called"")
    IllegalStateException responseChannelAlreadyProvided();

    @Message(id = 5, value = ""getRequestChannel() has already been called"")
    IllegalStateException requestChannelAlreadyProvided();

    // id = 6

    // id = 7

    @Message(id = 8, value = ""Handler cannot be null"")
    IllegalArgumentException handlerCannotBeNull();

    @Message(id = 9, value = ""Path must be specified"")
    IllegalArgumentException pathMustBeSpecified();

    @Message(id = 10, value = ""Session is invalid %s"")
    IllegalStateException sessionIsInvalid(String sessionId);

    @Message(id = 11, value = ""Session manager must not be null"")
    IllegalStateException sessionManagerMustNotBeNull();

    @Message(id = 12, value = ""Session manager was not attached to the request. Make sure that the SessionAttachmentHandler is installed in the handler chain"")
    IllegalStateException sessionManagerNotFound();

    @Message(id = 13, value = ""Argument %s cannot be null"")
    IllegalArgumentException argumentCannotBeNull(final String argument);

    @Message(id = 14, value = ""close() called with data still to be flushed. Please call shutdownWrites() and then call flush() until it returns true before calling close()"")
    IOException closeCalledWithDataStillToBeFlushed();

    @Message(id = 16, value = ""Could not add cookie as cookie handler was not present in the handler chain"")
    IllegalStateException cookieHandlerNotPresent();

    @Message(id = 17, value = ""Form value is a file, use getFile() instead"")
    IllegalStateException formValueIsAFile();

    @Message(id = 18, value = ""Form value is a String, use getValue() instead"")
    IllegalStateException formValueIsAString();

    @Message(id = 19, value = ""Connection from %s terminated as request entity was larger than %s"")
    IOException requestEntityWasTooLarge(SocketAddress address, long size);

    @Message(id = 20, value = ""Connection terminated as request was larger than %s"")
    IOException requestEntityWasTooLarge(long size);

    @Message(id = 21, value = ""Session already invalidated"")
    IllegalStateException sessionAlreadyInvalidated();

    @Message(id = 22, value = ""The specified hash algorithm '%s' can not be found."")
    IllegalArgumentException hashAlgorithmNotFound(String algorithmName);

    @Message(id = 23, value = ""An invalid Base64 token has been received."")
    IllegalArgumentException invalidBase64Token(@Cause final IOException cause);

    @Message(id = 24, value = ""An invalidly formatted nonce has been received."")
    IllegalArgumentException invalidNonceReceived();

    @Message(id = 25, value = ""Unexpected token '%s' within header."")
    IllegalArgumentException unexpectedTokenInHeader(final String name);

    @Message(id = 26, value = ""Invalid header received."")
    IllegalArgumentException invalidHeader();

    @Message(id = 27, value = ""Could not find session cookie config in the request"")
    IllegalStateException couldNotFindSessionCookieConfig();

    @Message(id = 28, value = ""Session %s already exists"")
    IllegalStateException sessionAlreadyExists(final String id);

    @Message(id = 29, value = ""Channel was closed mid chunk, if you have attempted to write chunked data you cannot shutdown the channel until after it has all been written."")
    IOException chunkedChannelClosedMidChunk();

    @Message(id = 30, value = ""User %s successfully authenticated."")
    String userAuthenticated(final String userName);

    @Message(id = 31, value = ""User %s has logged out."")
    String userLoggedOut(final String userName);

    @Message(id = 33, value = ""Authentication type %s cannot be combined with %s"")
    IllegalStateException authTypeCannotBeCombined(String type, String existing);

    @Message(id = 34, value = ""Stream is closed"")
    IOException streamIsClosed();

    @Message(id = 35, value = ""Cannot get stream as startBlocking has not been invoked"")
    IllegalStateException startBlockingHasNotBeenCalled();

    @Message(id = 36, value = ""Connection terminated parsing multipart data"")
    IOException connectionTerminatedReadingMultiPartData();

    @Message(id = 37, value = ""Failed to parse path in HTTP request"")
    RuntimeException failedToParsePath();

    @Message(id = 38, value = ""Authentication failed, requested user name '%s'"")
    String authenticationFailed(final String userName);

    @Message(id = 39, value = ""To many query parameters, cannot have more than %s query parameters"")
    RuntimeException tooManyQueryParameters(int noParams);

    @Message(id = 40, value = ""To many headers, cannot have more than %s header"")
    String tooManyHeaders(int noParams);

    @Message(id = 41, value = ""Channel is closed"")
    ClosedChannelException channelIsClosed();

    @Message(id = 42, value = ""Could not decode trailers in HTTP request"")
    IOException couldNotDecodeTrailers();

    @Message(id = 43, value = ""Data is already being sent. You must wait for the completion callback to be be invoked before calling send() again"")
    IllegalStateException dataAlreadyQueued();

    @Message(id = 44, value = ""More than one predicate with name %s. Builder class %s and %s"")
    IllegalStateException moreThanOnePredicateWithName(String name, Class<? extends PredicateBuilder> aClass, Class<? extends PredicateBuilder> existing);

    @Message(id = 45, value = ""Error parsing predicated handler string %s:%n%s"")
    IllegalArgumentException errorParsingPredicateString(String reason, String s);

    @Message(id = 46, value = ""The number of cookies sent exceeded the maximum of %s"")
    IllegalStateException tooManyCookies(int maxCookies);

    @Message(id = 47, value = ""The number of parameters exceeded the maximum of %s"")
    ParameterLimitException tooManyParameters(int maxValues);

    @Message(id = 48, value = ""No request is currently active"")
    IllegalStateException noRequestActive();

    @Message(id = 50, value = ""AuthenticationMechanism Outcome is null"")
    IllegalStateException authMechanismOutcomeNull();

    @Message(id = 51, value = ""Not a valid IP pattern %s"")
    IllegalArgumentException notAValidIpPattern(String peer);

    @Message(id = 52, value = ""Session data requested when non session based authentication in use"")
    IllegalStateException noSessionData();

    @Message(id = 53, value = ""Listener %s already registered"")
    IllegalArgumentException listenerAlreadyRegistered(String name);

    @Message(id = 54, value = ""The maximum size %s for an individual file in a multipart request was exceeded"")
    IOException maxFileSizeExceeded(long maxIndividualFileSize);

    @Message(id = 55, value = ""Could not set attribute %s to %s as it is read only"")
    String couldNotSetAttribute(String attributeName, String newValue);

    @Message(id = 56, value = ""Could not parse URI template %s, exception at char %s"")
    RuntimeException couldNotParseUriTemplate(String path, int i);

    @Message(id = 57, value = ""Mismatched braces in attribute string %s"")
    RuntimeException mismatchedBraces(String valueString);

    @Message(id = 58, value = ""More than one handler with name %s. Builder class %s and %s"")
    IllegalStateException moreThanOneHandlerWithName(String name, Class<? extends HandlerBuilder> aClass, Class<? extends HandlerBuilder> existing);

    @Message(id = 59, value = ""Invalid syntax %s"")
    IllegalArgumentException invalidSyntax(String line);

    @Message(id = 60, value = ""Error parsing handler string %s:%n%s"")
    IllegalArgumentException errorParsingHandlerString(String reason, String s);

    @Message(id = 61, value = ""Out of band responses only allowed for 100-continue requests"")
    IllegalArgumentException outOfBandResponseOnlyAllowedFor100Continue();

    @Message(id = 62, value = ""AJP does not support HTTP upgrade"")
    IllegalStateException ajpDoesNotSupportHTTPUpgrade();

    @Message(id = 63, value = ""File system watcher already started"")
    IllegalStateException fileSystemWatcherAlreadyStarted();

    @Message(id = 64, value = ""File system watcher not started"")
    IllegalStateException fileSystemWatcherNotStarted();

    @Message(id = 65, value = ""SSL must be specified to connect to a https URL"")
    IOException sslWasNull();

    @Message(id = 66, value = ""Incorrect magic number %s for AJP packet header"")
    IOException wrongMagicNumber(int number);

    @Message(id = 67, value = ""No client cert was provided"")
    SSLPeerUnverifiedException peerUnverified();

    @Message(id = 68, value = ""Servlet path match failed"")
    IllegalArgumentException servletPathMatchFailed();

    @Message(id = 69, value = ""Could not parse set cookie header %s"")
    IllegalArgumentException couldNotParseCookie(String headerValue);

    @Message(id = 70, value = ""method can only be called by IO thread"")
    IllegalStateException canOnlyBeCalledByIoThread();

    @Message(id = 71, value = ""Cannot add path template %s, matcher already contains an equivalent pattern %s"")
    IllegalStateException matcherAlreadyContainsTemplate(String templateString, String templateString1);

    @Message(id = 72, value = ""Failed to decode url %s to charset %s"")
    IllegalArgumentException failedToDecodeURL(String s, String enc, @Cause Exception e);


    @Message(id = 73, value = ""Resource change listeners are not supported"")
    IllegalArgumentException resourceChangeListenerNotSupported();

    @Message(id = 74, value = ""Could not renegotiate SSL connection to require client certificate, as client had sent more data"")
    IllegalStateException couldNotRenegotiate();

    @Message(id = 75, value = ""Object was freed"")
    IllegalStateException objectWasFreed();

    @Message(id = 76, value = ""Handler not shutdown"")
    IllegalStateException handlerNotShutdown();

    @Message(id = 77, value = ""The underlying transport does not support HTTP upgrade"")
    IllegalStateException upgradeNotSupported();

    @Message(id = 78, value = ""Renegotiation not supported"")
    IOException renegotiationNotSupported();

    @Message(id = 79, value = ""Not a valid user agent pattern %s"")
    IllegalArgumentException notAValidUserAgentPattern(String userAgent);

    @Message(id = 80, value = ""Not a valid regular expression pattern %s"")
    IllegalArgumentException notAValidRegularExpressionPattern(String pattern);

    @Message(id = 81, value = ""Bad request"")
    RuntimeException badRequest();

    @Message(id = 82, value = ""Host %s already registered"")
    RuntimeException hostAlreadyRegistered(Object host);

    @Message(id = 83, value = ""Host %s has not been registered"")
    RuntimeException hostHasNotBeenRegistered(Object host);

    @Message(id = 84, value = ""Attempted to write additional data after the last chunk"")
    IOException extraDataWrittenAfterChunkEnd();

    @Message(id = 85, value = ""Could not generate unique session id"")
    RuntimeException couldNotGenerateUniqueSessionId();

    @Message(id = 86, value = ""SPDY needs to be provided with a heap buffer pool, for use in compressing and decompressing headers."")
    IllegalArgumentException mustProvideHeapBuffer();

    @Message(id = 87, value = ""Unexpected SPDY frame type %s"")
    IOException unexpectedFrameType(int type);

    @Message(id = 88, value = ""SPDY control frames cannot have body content"")
    IOException controlFrameCannotHaveBodyContent();

//    @Message(id = 89, value = ""SPDY not supported"")
//    IOException spdyNotSupported();

    @Message(id = 90, value = ""No ALPN implementation available (tried Jetty ALPN and JDK9)"")
    IOException alpnNotAvailable();

    @Message(id = 91, value = ""Buffer has already been freed"")
    IllegalStateException bufferAlreadyFreed();

    @Message(id = 92, value = ""A SPDY header was too large to fit in a response buffer, if you want to support larger headers please increase the buffer size"")
    IllegalStateException headersTooLargeToFitInHeapBuffer();

//    @Message(id = 93, value = ""A SPDY stream was reset by the remote endpoint"")
//    IOException spdyStreamWasReset();

    @Message(id = 94, value = ""Blocking await method called from IO thread. Blocking IO must be dispatched to a worker thread or deadlocks will result."")
    IOException awaitCalledFromIoThread();

    @Message(id = 95, value = ""Recursive call to flushSenders()"")
    RuntimeException recursiveCallToFlushingSenders();

    @Message(id = 96, value = ""More data was written to the channel than specified in the content-length"")
    IllegalStateException fixedLengthOverflow();

    @Message(id = 97, value = ""AJP request already in progress"")
    IllegalStateException ajpRequestAlreadyInProgress();

    @Message(id = 98, value = ""HTTP ping data must be 8 bytes in length"")
    String httpPingDataMustBeLength8();

    @Message(id = 99, value = ""Received a ping of size other than 8"")
    String invalidPingSize();

    @Message(id = 100, value = ""stream id must be zero for frame type %s"")
    String streamIdMustBeZeroForFrameType(int frameType);

    @Message(id = 101, value = ""stream id must not be zero for frame type %s"")
    String streamIdMustNotBeZeroForFrameType(int frameType);

    @Message(id = 102, value = ""RST_STREAM received for idle stream"")
    String rstStreamReceivedForIdleStream();

    @Message(id = 103, value = ""Http2 stream was reset"")
    IOException http2StreamWasReset();

    @Message(id = 104, value = ""Incorrect HTTP2 preface"")
    IOException incorrectHttp2Preface();

    @Message(id = 105, value = ""HTTP2 frame to large"")
    IOException http2FrameTooLarge();

    @Message(id = 106, value = ""HTTP2 continuation frame received without a corresponding headers or push promise frame"")
    IOException http2ContinuationFrameNotExpected();

    @Message(id = 107, value = ""Huffman encoded value in HPACK headers did not end with EOS padding"")
    HpackException huffmanEncodedHpackValueDidNotEndWithEOS();

    @Message(id = 108, value = ""HPACK variable length integer encoded over too many octects, max is %s"")
    HpackException integerEncodedOverTooManyOctets(int maxIntegerOctets);

    @Message(id = 109, value = ""Zero is not a valid header table index"")
    HpackException zeroNotValidHeaderTableIndex();


    @Message(id = 110, value = ""Cannot send 100-Continue, getResponseChannel() has already been called"")
    IOException cannotSendContinueResponse();

    @Message(id = 111, value = ""Parser did not make progress"")
    IOException parserDidNotMakeProgress();

    @Message(id = 112, value = ""Only client side can call createStream, if you wish to send a PUSH_PROMISE frame use createPushPromiseStream instead"")
    IOException headersStreamCanOnlyBeCreatedByClient();

    @Message(id = 113, value = ""Only the server side can send a push promise stream"")
    IOException pushPromiseCanOnlyBeCreatedByServer();

    @Message(id = 114, value = ""Invalid IP access control rule %s. Format is: [ip-match] allow|deny"")
    IllegalArgumentException invalidAclRule(String rule);

    @Message(id = 115, value = ""Server received PUSH_PROMISE frame from client"")
    IOException serverReceivedPushPromise();

    @Message(id = 116, value = ""CONNECT not supported by this connector"")
    IllegalStateException connectNotSupported();

    @Message(id = 117, value = ""Request was not a CONNECT request"")
    IllegalStateException notAConnectRequest();

    @Message(id = 118, value = ""Cannot reset buffer, response has already been commited"")
    IllegalStateException cannotResetBuffer();

    @Message(id = 119, value = ""HTTP2 via prior knowledge failed"")
    IOException http2PriRequestFailed();

    @Message(id = 120, value = ""Out of band responses are not allowed for this connector"")
    IllegalStateException outOfBandResponseNotSupported();

    @Message(id = 121, value = ""Session was rejected as the maximum number of sessions (%s) has been hit"")
    IllegalStateException tooManySessions(int maxSessions);

    @Message(id = 122, value = ""CONNECT attempt failed as target proxy returned %s"")
    IOException proxyConnectionFailed(int responseCode);

    @Message(id = 123, value = ""MCMP message %s rejected due to suspicious characters"")
    RuntimeException mcmpMessageRejectedDueToSuspiciousCharacters(String data);

    @Message(id = 124, value = ""renegotiation timed out"")
    IllegalStateException rengotiationTimedOut();

    @Message(id = 125, value = ""Request body already read"")
    IllegalStateException requestBodyAlreadyRead();

    @Message(id = 126, value = ""Attempted to do blocking IO from the IO thread. This is prohibited as it may result in deadlocks"")
    IllegalStateException blockingIoFromIOThread();

    @Message(id = 127, value = ""Response has already been sent"")
    IllegalStateException responseComplete();

    @Message(id = 128, value = ""Remote peer closed connection before all data could be read"")
    IOException couldNotReadContentLengthData();

    @Message(id = 129, value = ""Failed to send after being safe to send"")
    IllegalStateException failedToSendAfterBeingSafe();

    @Message(id = 130, value = ""HTTP reason phrase was too large for the buffer. Either provide a smaller message or a bigger buffer. Phrase: %s"")
    IllegalStateException reasonPhraseToLargeForBuffer(String phrase);

    @Message(id = 131, value = ""Buffer pool is closed"")
    IllegalStateException poolIsClosed();

    @Message(id = 132, value = ""HPACK decode failed"")
    HpackException hpackFailed();

    @Message(id = 133, value = ""Request did not contain an Upgrade header, upgrade is not permitted"")
    IllegalStateException notAnUpgradeRequest();

    @Message(id = 134, value = ""Authentication mechanism %s requires property %s to be set"")
    IllegalStateException authenticationPropertyNotSet(String name, String header);

    @Message(id = 135, value = ""renegotiation failed"")
    IllegalStateException rengotiationFailed();

    @Message(id = 136, value = ""User agent charset string must have an even number of items, in the form pattern,charset,pattern,charset,... Instead got: %s"")
    IllegalArgumentException userAgentCharsetMustHaveEvenNumberOfItems(String supplied);

    @Message(id = 137, value = ""Could not find the datasource called %s"")
    IllegalArgumentException datasourceNotFound(String ds);

    @Message(id = 138, value = ""Server not started"")
    IllegalStateException serverNotStarted();

    @Message(id = 139, value = ""Exchange already complete"")
    IllegalStateException exchangeAlreadyComplete();

    @Message(id = 140, value = ""Initial SSL/TLS data is not a handshake record"")
    SSLHandshakeException notHandshakeRecord();

    @Message(id = 141, value = ""Initial SSL/TLS handshake record is invalid"")
    SSLHandshakeException invalidHandshakeRecord();

    @Message(id = 142, value = ""Initial SSL/TLS handshake spans multiple records"")
    SSLHandshakeException multiRecordSSLHandshake();

    @Message(id = 143, value = ""Expected \""client hello\"" record"")
    SSLHandshakeException expectedClientHello();

    @Message(id = 144, value = ""Expected server hello"")
    SSLHandshakeException expectedServerHello();

    @Message(id = 145, value = ""Too many redirects"")
    IOException tooManyRedirects(@Cause IOException exception);

    @Message(id = 146, value = ""HttpServerExchange cannot have both async IO resumed and dispatch() called in the same cycle"")
    IllegalStateException resumedAndDispatched();

    @Message(id = 147, value = ""No host header in a HTTP/1.1 request"")
    IOException noHostInHttp11Request();

    @Message(id = 148, value = ""Invalid HPack encoding. First byte: %s"")
    HpackException invalidHpackEncoding(byte b);

    @Message(id = 149, value = ""HttpString is not allowed to contain newlines. value: %s"")
    IllegalArgumentException newlineNotSupportedInHttpString(String value);

    @Message(id = 150, value = ""Pseudo header %s received after receiving normal headers. Pseudo headers must be the first headers in a HTTP/2 header block."")
    String pseudoHeaderInWrongOrder(HttpString header);

    @Message(id = 151, value = ""Expected to receive a continuation frame"")
    String expectedContinuationFrame();

    @Message(id = 152, value = ""Incorrect frame size"")
    String incorrectFrameSize();

    @Message(id = 153, value = ""Stream id not registered"")
    IllegalStateException streamNotRegistered();

    @Message(id = 154, value = ""Mechanism %s returned a null result from sendChallenge()"")
    NullPointerException sendChallengeReturnedNull(AuthenticationMechanism mechanism);

    @Message(id = 155, value = ""Framed channel body was set when it was not ready for flush"")
    IllegalStateException bodyIsSetAndNotReadyForFlush();

    @Message(id = 156, value = ""Invalid GZIP header"")
    IOException invalidGzipHeader();

    @Message(id = 157, value = ""Invalid GZIP footer"")
    IOException invalidGZIPFooter();
}
"
"core/src/main/java/io/undertow/UndertowOptions.java:[26,290]:UndertowOptions","public class UndertowOptions {

    /**
     * The maximum size in bytes of a http request header.
     */
    public static final Option<Integer> MAX_HEADER_SIZE = Option.simple(UndertowOptions.class, ""MAX_HEADER_SIZE"", Integer.class);
    /**
     * The default size we allow for the HTTP header.
     */
    public static final int DEFAULT_MAX_HEADER_SIZE = 1024 * 1024;

    /**
     * The default maximum size of the HTTP entity body.
     */
    public static final Option<Long> MAX_ENTITY_SIZE = Option.simple(UndertowOptions.class, ""MAX_ENTITY_SIZE"", Long.class);

    /**
     * The default maximum size of the HTTP entity body when using the mutiltipart parser. Generall this will be larger than {@link #MAX_ENTITY_SIZE}.
     *
     * If this is not specified it will be the same as {@link #MAX_ENTITY_SIZE}.
     */
    public static final Option<Long> MULTIPART_MAX_ENTITY_SIZE = Option.simple(UndertowOptions.class, ""MULTIPART_MAX_ENTITY_SIZE"", Long.class);

    /**
     * We do not have a default upload limit
     */
    public static final long DEFAULT_MAX_ENTITY_SIZE = -1;

    /**
     * If we should buffer pipelined requests. Defaults to false.
     */
    public static final Option<Boolean> BUFFER_PIPELINED_DATA = Option.simple(UndertowOptions.class, ""BUFFER_PIPELINED_DATA"", Boolean.class);

    /**
     * The idle timeout in milliseconds after which the channel will be closed.
     *
     * If the underlying channel already has a read or write timeout set the smaller of the two values will be used
     * for read/write timeouts.
     *
     */
    public static final Option<Integer> IDLE_TIMEOUT = Option.simple(UndertowOptions.class, ""IDLE_TIMEOUT"", Integer.class);

    /**
     * The maximum allowed time of reading HTTP request in milliseconds.
     *
     * <code>-1</code> or missing value disables this functionality.
     */
    public static final Option<Integer> REQUEST_PARSE_TIMEOUT = Option.simple(UndertowOptions.class, ""REQUEST_PARSE_TIMEOUT"", Integer.class);

    /**
     * The amount of time the connection can be idle with no current requests before it is closed;
     */
    public static final Option<Integer> NO_REQUEST_TIMEOUT = Option.simple(UndertowOptions.class, ""NO_REQUEST_TIMEOUT"", Integer.class);

    public static final int DEFAULT_MAX_PARAMETERS = 1000;

    /**
     * The maximum number of parameters that will be parsed. This is used to protect against hash vulnerabilities.
     * <p>
     * This applies to both query parameters, and to POST data, but is not cumulative (i.e. you can potentially have
     * max parameters * 2 total parameters).
     * <p>
     * Defaults to 1000
     */
    public static final Option<Integer> MAX_PARAMETERS = Option.simple(UndertowOptions.class, ""MAX_PARAMETERS"", Integer.class);

    public static final int DEFAULT_MAX_HEADERS = 200;

    /**
     * The maximum number of headers that will be parsed. This is used to protect against hash vulnerabilities.
     * <p>
     * Defaults to 200
     */
    public static final Option<Integer> MAX_HEADERS = Option.simple(UndertowOptions.class, ""MAX_HEADERS"", Integer.class);


    /**
     * The maximum number of cookies that will be parsed. This is used to protect against hash vulnerabilities.
     * <p>
     * Defaults to 200
     */
    public static final Option<Integer> MAX_COOKIES = Option.simple(UndertowOptions.class, ""MAX_COOKIES"", Integer.class);

    /**
     * If a request comes in with encoded / characters (i.e. %2F), will these be decoded.
     * <p>
     * This can cause security problems if a front end proxy does not perform the same decoding, and as a result
     * this is disabled by default.
     * <p>
     * Defaults to false
     *
     * See <a href=""http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-0450"">CVE-2007-0450</a>
     */
    public static final Option<Boolean> ALLOW_ENCODED_SLASH = Option.simple(UndertowOptions.class, ""ALLOW_ENCODED_SLASH"", Boolean.class);

    /**
     * If this is true then the parser will decode the URL and query parameters using the selected character encoding (UTF-8 by default). If this is false they will
     * not be decoded. This will allow a later handler to decode them into whatever charset is desired.
     * <p>
     * Defaults to true.
     */
    public static final Option<Boolean> DECODE_URL = Option.simple(UndertowOptions.class, ""DECODE_URL"", Boolean.class);


    /**
     * If this is true then the parser will decode the URL and query parameters using the selected character encoding (UTF-8 by default). If this is false they will
     * not be decoded. This will allow a later handler to decode them into whatever charset is desired.
     * <p>
     * Defaults to true.
     */
    public static final Option<String> URL_CHARSET = Option.simple(UndertowOptions.class, ""URL_CHARSET"", String.class);

    /**
     * If this is true then a Connection: keep-alive header will be added to responses, even when it is not strictly required by
     * the specification.
     * <p>
     * Defaults to true
     */
    public static final Option<Boolean> ALWAYS_SET_KEEP_ALIVE = Option.simple(UndertowOptions.class, ""ALWAYS_SET_KEEP_ALIVE"", Boolean.class);

    /**
     * If this is true then a Date header will be added to all responses. The HTTP spec says this header should be added to all
     * responses, unless the server does not have an accurate clock.
     * <p>
     * Defaults to true
     */
    public static final Option<Boolean> ALWAYS_SET_DATE = Option.simple(UndertowOptions.class, ""ALWAYS_SET_DATE"", Boolean.class);

    /**
     * Maximum size of a buffered request, in bytes
     * <p>
     * Requests are not usually buffered, the most common case is when performing SSL renegotiation for a POST request, and the post data must be fully
     * buffered in order to perform the renegotiation.
     * <p>
     * Defaults to 16384.
     */
    public static final Option<Integer> MAX_BUFFERED_REQUEST_SIZE = Option.simple(UndertowOptions.class, ""MAX_BUFFERED_REQUEST_SIZE"", Integer.class);

    /**
     * If this is true then Undertow will record the request start time, to allow for request time to be logged
     *
     * This has a small but measurable performance impact
     *
     * default is false
     */
    public static final Option<Boolean> RECORD_REQUEST_START_TIME = Option.simple(UndertowOptions.class, ""RECORD_REQUEST_START_TIME"", Boolean.class);

    /**
     * If this is true then Undertow will allow non-escaped equals characters in unquoted cookie values.
     * <p>
     * Unquoted cookie values may not contain equals characters. If present the value ends before the equals sign. The remainder of the cookie value will be dropped.
     * <p>
     * default is false
     */
    public static final Option<Boolean> ALLOW_EQUALS_IN_COOKIE_VALUE = Option.simple(UndertowOptions.class, ""ALLOW_EQUALS_IN_COOKIE_VALUE"", Boolean.class);

    /**
     * If we should attempt to use SPDY for HTTPS connections.
     *
     * SPDY is no longer supported, use HTTP/2 instead
     */
    @Deprecated
    public static final Option<Boolean> ENABLE_SPDY = Option.simple(UndertowOptions.class, ""ENABLE_SPDY"", Boolean.class);

    /**
     * If we should attempt to use HTTP2 for HTTPS connections.
     */
    public static final Option<Boolean> ENABLE_HTTP2 = Option.simple(UndertowOptions.class, ""ENABLE_HTTP2"", Boolean.class);

    /**
     * If connector level statistics should be enabled. This has a slight performance impact, but allows statistics such
     * as bytes sent/recevied to be monitored.
     *
     * If this is passed to the client then client statistics will be enabled.
     *
     */
    public static final Option<Boolean> ENABLE_STATISTICS = Option.simple(UndertowOptions.class, ""ENABLE_STATISTICS"", Boolean.class);


    /**
     * If connector level statistics should be enabled. This has a slight performance impact, but allows statistics such
     * as bytes sent/recevied to be monitored.
     */
    @Deprecated
    public static final Option<Boolean> ENABLE_CONNECTOR_STATISTICS = ENABLE_STATISTICS;


    /**
     * If unknown protocols should be allowed. The known protocols are:
     *
     * HTTP/0.9
     * HTTP/1.0
     * HTTP/1.1
     * HTTP/2.0
     *
     * If this is false then requests that specify any other protocol will be rejected with a 400
     *
     * Defaults to false
     */
    public static final Option<Boolean> ALLOW_UNKNOWN_PROTOCOLS = Option.simple(UndertowOptions.class, ""ALLOW_UNKNOWN_PROTOCOLS"", Boolean.class);

    /**
     * The size of the header table that is used in the encoder
     */
    public static final Option<Integer> HTTP2_SETTINGS_HEADER_TABLE_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_HEADER_TABLE_SIZE"", Integer.class);
    public static final int HTTP2_SETTINGS_HEADER_TABLE_SIZE_DEFAULT = 4096;

    /**
     * If push should be enabled for this connection.
     */
    public static final Option<Boolean> HTTP2_SETTINGS_ENABLE_PUSH = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_ENABLE_PUSH"", Boolean.class);

    /**
     * The maximum number of concurrent
     */
    public static final Option<Integer> HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS"", Integer.class);

    public static final Option<Integer> HTTP2_SETTINGS_INITIAL_WINDOW_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_INITIAL_WINDOW_SIZE"", Integer.class);
    public static final Option<Integer> HTTP2_SETTINGS_MAX_FRAME_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_MAX_FRAME_SIZE"", Integer.class);
    public static final Option<Integer> HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE"", Integer.class);

    /**
     * The maximum amount of padding to send in a HTTP/2 frame. Actual amount will be randomly determined, defaults to Zero.
     */
    public static final Option<Integer> HTTP2_PADDING_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_PADDING_SIZE"", Integer.class);

    /**
     * Undertow keeps a LRU cache of common huffman encodings. This sets the maximum size, setting this to 0 will disable the caching.
     *
     */
    public static final Option<Integer> HTTP2_HUFFMAN_CACHE_SIZE = Option.simple(UndertowOptions.class, ""HTTP2_HUFFMAN_CACHE_SIZE"", Integer.class);

    /**
     * The maximum number of concurrent requests that will be processed at a time. This differs from max concurrent streams in that it is not sent to the remote client.
     *
     * If the number of pending requests exceeds this number then requests will be queued, the difference between this and max concurrent streams determins
     * the maximum number of requests that will be queued.
     *
     * Queued requests are processed by a priority queue, rather than a FIFO based queue, using HTTP2 stream priority.
     *
     * If this number is smaller than or equal to zero then max concurrent streams determines the maximum number of streams that can be run.
     *
     *
     */
    public static final Option<Integer> MAX_CONCURRENT_REQUESTS_PER_CONNECTION = Option.simple(UndertowOptions.class, ""MAX_CONCURRENT_REQUESTS_PER_CONNECTION"", Integer.class);

    /**
     * The maximum number of buffers that will be used before reads are paused in framed protocols. Defaults to 10
     */
    public static final Option<Integer> MAX_QUEUED_READ_BUFFERS = Option.simple(UndertowOptions.class, ""MAX_QUEUED_READ_BUFFERS"", Integer.class);

    /**
     * The maximum AJP packet size, default is 8192
     */
    public static final Option<Integer> MAX_AJP_PACKET_SIZE = Option.simple(UndertowOptions.class, ""MAX_AJP_PACKET_SIZE"", Integer.class);

    /**
     * If this is true then HTTP/1.1 requests will be failed if no host header is present.
     */
    public static final Option<Boolean> REQUIRE_HOST_HTTP11 = Option.simple(UndertowOptions.class, ""REQUIRE_HOST_HTTP11"", Boolean.class);

    private UndertowOptions() {

    }
}
"
"core/src/test/java/io/undertow/server/protocol/http/ParserResumeTestCase.java:[37,103]:ParserResumeTestCase","public class ParserResumeTestCase {

    public static final String DATA = ""GET http://www.somehost.net/apath+with+spaces%20and%20I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n?key1=value1&key2=I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\nHostee:another\r\nAccept-garbage:   a\r\n\r\ntttt"";
    public static final HttpRequestParser PARSER = HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true));

    final ParseState context = new ParseState();
    @Test
    public void testMethodSplit() {
        byte[] in = DATA.getBytes();
        for (int i = 0; i < in.length - 4; ++i) {
            try {
                testResume(i, in);
            } catch (Throwable e) {
                throw new RuntimeException(""Test failed at split "" + i, e);
            }
        }
    }

    @Test
    public void testOneCharacterAtATime() throws HttpRequestParser.BadRequestException {
        context.reset();
        byte[] in = DATA.getBytes();
        HttpServerExchange result = new HttpServerExchange(null);
        ByteBuffer buffer = ByteBuffer.wrap(in);
        int oldLimit = buffer.limit();
        buffer.limit(1);
        while (context.state != ParseState.PARSE_COMPLETE) {
            PARSER.handle(buffer, context, result);
            if(context.state != ParseState.PARSE_COMPLETE) {
                buffer.limit(buffer.limit() + 1);
            }
        }
        Assert.assertEquals(oldLimit, buffer.limit() + 4);
        runAssertions(result);
    }

    private void testResume(final int split, byte[] in) throws HttpRequestParser.BadRequestException {
        context.reset();
        HttpServerExchange result = new HttpServerExchange(null);
        ByteBuffer buffer = ByteBuffer.wrap(in);
        buffer.limit(split);
        PARSER.handle(buffer, context, result);
        buffer.limit(buffer.capacity());
        PARSER.handle(buffer, context, result);
        runAssertions(result);
        Assert.assertEquals(4, buffer.remaining());
    }

    private void runAssertions(final HttpServerExchange result) {
        Assert.assertSame(Methods.GET, result.getRequestMethod());
        Assert.assertEquals(""/apath with spaces and IÃ±tÃ«rnÃ¢tiÃ´nÃ liÅ¾Ã¦tiÃ¸n"", result.getRelativePath());
        Assert.assertEquals(""http://www.somehost.net/apath+with+spaces%20and%20I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n"", result.getRequestURI());
        Assert.assertSame(Protocols.HTTP_1_1, result.getProtocol());

        Assert.assertEquals(""www.somehost.net"", result.getRequestHeaders().getFirst(new HttpString(""Host"")));
        Assert.assertEquals(""some value"", result.getRequestHeaders().getFirst(new HttpString(""OtherHeader"")));
        Assert.assertEquals(""another"", result.getRequestHeaders().getFirst(new HttpString(""Hostee"")));
        Assert.assertEquals(""a"", result.getRequestHeaders().getFirst(new HttpString(""Accept-garbage"")));
        Assert.assertEquals(4, result.getRequestHeaders().getHeaderNames().size());

        Assert.assertEquals(ParseState.PARSE_COMPLETE, context.state);
        Assert.assertEquals(""key1=value1&key2=I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n"", result.getQueryString());
        Assert.assertEquals(""value1"", result.getQueryParameters().get(""key1"").getFirst());
        Assert.assertEquals(""IÃ±tÃ«rnÃ¢tiÃ´nÃ liÅ¾Ã¦tiÃ¸n"", result.getQueryParameters().get(""key2"").getFirst());
    }

}
"
"core/src/test/java/io/undertow/server/protocol/http/ParserResumeTestCase.java:[42,42]:context","    final ParseState context = new ParseState();
"
"core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java:[157,863]:HttpRequestParser","public abstract class HttpRequestParser {

    private static final byte[] HTTP;
    public static final int HTTP_LENGTH;

    private final int maxParameters;
    private final int maxHeaders;
    private final boolean allowEncodedSlash;
    private final boolean decode;
    private final String charset;

    static {
        try {
            HTTP = ""HTTP/1."".getBytes(""ASCII"");
            HTTP_LENGTH = HTTP.length;
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public HttpRequestParser(OptionMap options) {
        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS);
        allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
        decode = options.get(UndertowOptions.DECODE_URL, true);
        charset = options.get(UndertowOptions.URL_CHARSET, StandardCharsets.UTF_8.name());
    }

    public static final HttpRequestParser instance(final OptionMap options) {
        try {
            final Class<?> cls = Class.forName(HttpRequestParser.class.getName() + ""$$generated"", false, HttpRequestParser.class.getClassLoader());

            Constructor<?> ctor = cls.getConstructor(OptionMap.class);
            return (HttpRequestParser) ctor.newInstance(options);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) throws BadRequestException {
        if (currentState.state == ParseState.VERB) {
            //fast path, we assume that it will parse fully so we avoid all the if statements

            //fast path HTTP GET requests, basically just assume all requests are get
            //and fall out to the state machine if it is not
            final int position = buffer.position();
            if (buffer.remaining() > 3
                    && buffer.get(position) == 'G'
                    && buffer.get(position + 1) == 'E'
                    && buffer.get(position + 2) == 'T'
                    && buffer.get(position + 3) == ' ') {
                buffer.position(position + 4);
                builder.setRequestMethod(Methods.GET);
                currentState.state = ParseState.PATH;
            } else {
                handleHttpVerb(buffer, currentState, builder);
            }
            handlePath(buffer, currentState, builder);
            boolean failed = false;
            if (buffer.remaining() > HTTP_LENGTH + 3) {
                int pos = buffer.position();
                for (int i = 0; i < HTTP_LENGTH; ++i) {
                    if (HTTP[i] != buffer.get(pos + i)) {
                        failed = true;
                        break;
                    }
                }
                if (!failed) {
                    final byte b = buffer.get(pos + HTTP_LENGTH);
                    final byte b2 = buffer.get(pos + HTTP_LENGTH + 1);
                    final byte b3 = buffer.get(pos + HTTP_LENGTH + 2);
                    if (b2 == '\r' && b3 == '\n') {
                        if (b == '1') {
                            builder.setProtocol(Protocols.HTTP_1_1);
                            buffer.position(pos + HTTP_LENGTH + 3);
                            currentState.state = ParseState.HEADER;
                        } else if (b == '0') {
                            builder.setProtocol(Protocols.HTTP_1_0);
                            buffer.position(pos + HTTP_LENGTH + 3);
                            currentState.state = ParseState.HEADER;
                        } else {
                            failed = true;
                        }
                    } else {
                        failed = true;
                    }
                }
            } else {
                failed = true;
            }
            if (failed) {
                handleHttpVersion(buffer, currentState, builder);
                handleAfterVersion(buffer, currentState);
            }

            while (currentState.state != ParseState.PARSE_COMPLETE && buffer.hasRemaining()) {
                handleHeader(buffer, currentState, builder);
                if (currentState.state == ParseState.HEADER_VALUE) {
                    handleHeaderValue(buffer, currentState, builder);
                }
            }
            return;
        }
        handleStateful(buffer, currentState, builder);
    }

    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) throws BadRequestException {
        if (currentState.state == ParseState.PATH) {
            handlePath(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.QUERY_PARAMETERS) {
            handleQueryParameters(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.PATH_PARAMETERS) {
            handlePathParameters(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.VERSION) {
            handleHttpVersion(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }
        if (currentState.state == ParseState.AFTER_VERSION) {
            handleAfterVersion(buffer, currentState);
            if (!buffer.hasRemaining()) {
                return;
            }
        }
        while (currentState.state != ParseState.PARSE_COMPLETE) {
            if (currentState.state == ParseState.HEADER) {
                handleHeader(buffer, currentState, builder);
                if (!buffer.hasRemaining()) {
                    return;
                }
            }
            if (currentState.state == ParseState.HEADER_VALUE) {
                handleHeaderValue(buffer, currentState, builder);
                if (!buffer.hasRemaining()) {
                    return;
                }
            }
        }
    }


    abstract void handleHttpVerb(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    abstract void handleHttpVersion(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    abstract void handleHeader(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    /**
     * The parse states for parsing the path.
     */
    private static final int START = 0;
    private static final int FIRST_COLON = 1;
    private static final int FIRST_SLASH = 2;
    private static final int SECOND_SLASH = 3;
    private static final int IN_PATH = 4;
    private static final int HOST_DONE = 5;

    /**
     * Parses a path value
     *
     * @param buffer   The buffer
     * @param state    The current state
     * @param exchange The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handlePath(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int parseState = state.parseState;
        int canonicalPathStart = state.pos;
        boolean urlDecodeRequired = state.urlDecodeRequired;

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t') {
                if (stringBuilder.length() != 0) {
                    final String path = stringBuilder.toString();
                    if(parseState == SECOND_SLASH) {
                        exchange.setRequestPath(""/"");
                        exchange.setRelativePath(""/"");
                        exchange.setRequestURI(path);
                    } else if (parseState < HOST_DONE) {
                        String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
                        exchange.setRequestPath(decodedPath);
                        exchange.setRelativePath(decodedPath);
                        exchange.setRequestURI(path);
                    } else {
                        handleFullUrl(state, exchange, canonicalPathStart, urlDecodeRequired, path);
                    }
                    exchange.setQueryString("""");
                    state.state = ParseState.VERSION;
                    state.stringBuilder.setLength(0);
                    state.parseState = 0;
                    state.pos = 0;
                    state.urlDecodeRequired = false;
                    return;
                }
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else if (next == '?' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginQueryParameters(buffer, state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                return;
            } else if (next == ';' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginPathParameters(state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                handlePathParameters(buffer, state, exchange);
                return;
            } else {

                if (decode && (next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                } else if (next == ':' && parseState == START) {
                    parseState = FIRST_COLON;
                } else if (next == '/' && parseState == FIRST_COLON) {
                    parseState = FIRST_SLASH;
                } else if (next == '/' && parseState == FIRST_SLASH) {
                    parseState = SECOND_SLASH;
                } else if (next == '/' && parseState == SECOND_SLASH) {
                    parseState = HOST_DONE;
                    canonicalPathStart = stringBuilder.length();
                } else if (parseState == FIRST_COLON || parseState == FIRST_SLASH) {
                    parseState = IN_PATH;
                } else if (next == '/' && parseState != HOST_DONE) {
                    parseState = IN_PATH;
                }
                stringBuilder.append(next);
            }

        }
        state.parseState = parseState;
        state.pos = canonicalPathStart;
        state.urlDecodeRequired = urlDecodeRequired;
    }

    private void beginPathParameters(ParseState state, HttpServerExchange exchange, StringBuilder stringBuilder, int parseState, int canonicalPathStart, boolean urlDecodeRequired) {
        final String path = stringBuilder.toString();
        if(parseState == SECOND_SLASH) {
            exchange.setRequestPath(""/"");
            exchange.setRelativePath(""/"");
            exchange.setRequestURI(path);
        } else if (parseState < HOST_DONE) {
            String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
            exchange.setRequestPath(decodedPath);
            exchange.setRelativePath(decodedPath);
            exchange.setRequestURI(path);
        } else {
            String thePath = path.substring(canonicalPathStart);
            exchange.setRequestPath(thePath);
            exchange.setRelativePath(thePath);
            exchange.setRequestURI(path, true);
        }
        state.state = ParseState.PATH_PARAMETERS;
        state.stringBuilder.setLength(0);
        state.parseState = 0;
        state.pos = 0;
        state.urlDecodeRequired = false;
    }

    private void beginQueryParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange, StringBuilder stringBuilder, int parseState, int canonicalPathStart, boolean urlDecodeRequired) {
        final String path = stringBuilder.toString();
        if (parseState == SECOND_SLASH) {
            exchange.setRequestPath(""/"");
            exchange.setRelativePath(""/"");
            exchange.setRequestURI(path);
        } else if (parseState < HOST_DONE) {
            String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
            exchange.setRequestPath(decodedPath);
            exchange.setRelativePath(decodedPath);
            exchange.setRequestURI(path, false);
        } else {
            handleFullUrl(state, exchange, canonicalPathStart, urlDecodeRequired, path);
        }
        state.state = ParseState.QUERY_PARAMETERS;
        state.stringBuilder.setLength(0);
        state.parseState = 0;
        state.pos = 0;
        state.urlDecodeRequired = false;
        handleQueryParameters(buffer, state, exchange);
    }

    private void handleFullUrl(ParseState state, HttpServerExchange exchange, int canonicalPathStart, boolean urlDecodeRequired, String path) {
        String thePath = decode(path.substring(canonicalPathStart), urlDecodeRequired, state, allowEncodedSlash);
        exchange.setRequestPath(thePath);
        exchange.setRelativePath(thePath);
        exchange.setRequestURI(path, true);
    }


    /**
     * Parses a path value
     *
     * @param buffer   The buffer
     * @param state    The current state
     * @param exchange The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handleQueryParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int queryParamPos = state.pos;
        int mapCount = state.mapCount;
        boolean urlDecodeRequired = state.urlDecodeRequired;
        String nextQueryParam = state.nextQueryParam;

        //so this is a bit funky, because it not only deals with parsing, but
        //also deals with URL decoding the query parameters as well, while also
        //maintaining a non-decoded version to use as the query string
        //In most cases these string will be the same, and as we do not want to
        //build up two separate strings we don't use encodedStringBuilder unless
        //we encounter an encoded character

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t') {
                final String queryString = stringBuilder.toString();
                exchange.setQueryString(queryString);
                if (nextQueryParam == null) {
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addQueryParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                } else {
                    exchange.addQueryParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                }
                state.state = ParseState.VERSION;
                state.stringBuilder.setLength(0);
                state.pos = 0;
                state.nextQueryParam = null;
                state.urlDecodeRequired = false;
                state.mapCount = 0;
                return;
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else {
                if (decode && (next == '+' || next == '%' || next > 127)) { //+ is only a whitespace substitute in the query part of the URL
                    urlDecodeRequired = true;
                } else if (next == '=' && nextQueryParam == null) {
                    nextQueryParam = decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true);
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&' && nextQueryParam == null) {
                    if (++mapCount > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addQueryParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&') {
                    if (++mapCount > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    exchange.addQueryParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                    nextQueryParam = null;
                }
                stringBuilder.append(next);

            }

        }
        state.pos = queryParamPos;
        state.nextQueryParam = nextQueryParam;
        state.urlDecodeRequired = urlDecodeRequired;
        state.mapCount = mapCount;
    }

    private String decode(final String value, boolean urlDecodeRequired, ParseState state, final boolean allowEncodedSlash) {
        if (urlDecodeRequired) {
            return URLUtils.decode(value, charset, allowEncodedSlash, state.decodeBuffer);
        } else {
            return value;
        }
    }


    final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int queryParamPos = state.pos;
        int mapCount = state.mapCount;
        boolean urlDecodeRequired = state.urlDecodeRequired;
        String nextQueryParam = state.nextQueryParam;

        //so this is a bit funky, because it not only deals with parsing, but
        //also deals with URL decoding the query parameters as well, while also
        //maintaining a non-decoded version to use as the query string
        //In most cases these string will be the same, and as we do not want to
        //build up two separate strings we don't use encodedStringBuilder unless
        //we encounter an encoded character

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t' || next == '?') {
                if (nextQueryParam == null) {
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addPathParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                } else {
                    exchange.addPathParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                }
                exchange.setRequestURI(exchange.getRequestURI() + ';' + stringBuilder.toString(), state.parseState > HOST_DONE);
                state.stringBuilder.setLength(0);
                state.pos = 0;
                state.nextQueryParam = null;
                state.mapCount = 0;
                state.urlDecodeRequired = false;
                if (next == '?') {
                    state.state = ParseState.QUERY_PARAMETERS;
                    handleQueryParameters(buffer, state, exchange);
                } else {
                    state.state = ParseState.VERSION;
                }
                return;
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else {
                if (decode && (next == '+' || next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                }
                if (next == '=' && nextQueryParam == null) {
                    nextQueryParam = decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true);
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&' && nextQueryParam == null) {
                    if (++mapCount > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    exchange.addPathParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&') {
                    if (++mapCount > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }

                    exchange.addPathParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                    nextQueryParam = null;
                }
                stringBuilder.append(next);

            }

        }
        state.pos = queryParamPos;
        state.nextQueryParam = nextQueryParam;
        state.mapCount = mapCount;
        state.urlDecodeRequired = urlDecodeRequired;
    }


    /**
     * The parse states for parsing heading values
     */
    private static final int NORMAL = 0;
    private static final int WHITESPACE = 1;
    private static final int BEGIN_LINE_END = 2;
    private static final int LINE_END = 3;
    private static final int AWAIT_DATA_END = 4;

    /**
     * Parses a header value. This is called from the generated bytecode.
     *
     * @param buffer  The buffer
     * @param state   The current state
     * @param builder The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
        HttpString headerName = state.nextHeader;
        StringBuilder stringBuilder = state.stringBuilder;
        HashMap<HttpString, String> headerValuesCache = state.headerValuesCache;
        if (stringBuilder.length() == 0) {
            String existing = headerValuesCache.get(headerName);
            if (existing != null) {
                if (handleCachedHeader(existing, buffer, state, builder)) {
                    return;
                }
            }
        }

        handleHeaderValueCacheMiss(buffer, state, builder, headerName, headerValuesCache, stringBuilder);
    }

    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) throws BadRequestException {

        int parseState = state.parseState;
        while (buffer.hasRemaining() && parseState == NORMAL) {
            final byte next = buffer.get();
            if (next == '\r') {
                parseState = BEGIN_LINE_END;
            } else if (next == '\n') {
                parseState = LINE_END;
            } else if (next == ' ' || next == '\t') {
                parseState = WHITESPACE;
            } else {
                stringBuilder.append((char) (next & 0xFF));
            }
        }

        while (buffer.hasRemaining()) {
            final byte next = buffer.get();
            switch (parseState) {
                case NORMAL: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                        parseState = WHITESPACE;
                    } else {
                        stringBuilder.append((char) (next & 0xFF));
                    }
                    break;
                }
                case WHITESPACE: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                    } else {
                        if (stringBuilder.length() > 0) {
                            stringBuilder.append(' ');
                        }
                        stringBuilder.append((char) (next & 0xFF));
                        parseState = NORMAL;
                    }
                    break;
                }
                case LINE_END:
                case BEGIN_LINE_END: {
                    if (next == '\n' && parseState == BEGIN_LINE_END) {
                        parseState = LINE_END;
                    } else if (next == '\t' ||
                            next == ' ') {
                        //this is a continuation
                        parseState = WHITESPACE;
                    } else {
                        //we have a header
                        String headerValue = stringBuilder.toString();


                        if (++state.mapCount > maxHeaders) {
                            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
                        }
                        //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
                        builder.getRequestHeaders().add(headerName, headerValue);
                        if(headerValuesCache.size() < maxHeaders) {
                            //we have a limit on how many we can cache
                            //to prevent memory filling and hash collision attacks
                            headerValuesCache.put(headerName, headerValue);
                        }

                        state.nextHeader = null;

                        state.leftOver = next;
                        state.stringBuilder.setLength(0);
                        if (next == '\r') {
                            parseState = AWAIT_DATA_END;
                        } else if (next == '\n') {
                            state.state = ParseState.PARSE_COMPLETE;
                            return;
                        } else {
                            state.state = ParseState.HEADER;
                            state.parseState = 0;
                            return;
                        }
                    }
                    break;
                }
                case AWAIT_DATA_END: {
                    state.state = ParseState.PARSE_COMPLETE;
                    return;
                }
            }
        }
        //we only write to the state if we did not finish parsing
        state.parseState = parseState;
    }

    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
        int pos = buffer.position();
        while (pos < buffer.limit() && buffer.get(pos) == ' ') {
            pos++;
        }
        if (existing.length() + 3 + pos > buffer.limit()) {
            return false;
        }
        int i = 0;
        while (i < existing.length()) {
            byte b = buffer.get(pos + i);
            if (b != existing.charAt(i)) {
                return false;
            }
            ++i;
        }
        if (buffer.get(pos + i++) != '\r') {
            return false;
        }
        if (buffer.get(pos + i++) != '\n') {
            return false;
        }
        int next = buffer.get(pos + i);
        if (next == '\t' || next == ' ') {
            //continuation
            return false;
        }
        buffer.position(pos + i);
        if (++state.mapCount > maxHeaders) {
            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
        }
        //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
        builder.getRequestHeaders().add(state.nextHeader, existing);

        state.nextHeader = null;

        state.state = ParseState.HEADER;
        state.parseState = 0;
        return true;
    }

    protected void handleAfterVersion(ByteBuffer buffer, ParseState state) {
        boolean newLine = state.leftOver == '\n';
        while (buffer.hasRemaining()) {
            final byte next = buffer.get();
            if (newLine) {
                if (next == '\n') {
                    state.state = ParseState.PARSE_COMPLETE;
                    return;
                } else {
                    state.state = ParseState.HEADER;
                    state.leftOver = next;
                    return;
                }
            } else {
                if (next == '\n') {
                    newLine = true;
                } else if (next != '\r' && next != ' ' && next != '\t') {
                    state.state = ParseState.HEADER;
                    state.leftOver = next;
                    return;
                } else {
                    throw UndertowMessages.MESSAGES.badRequest();
                }
            }
        }
        if (newLine) {
            state.leftOver = '\n';
        }
    }

    /**
     * This is a bit of hack to enable the parser to get access to the HttpString's that are sorted
     * in the static fields of the relevant classes. This means that in most cases a HttpString comparison
     * will take the fast path == route, as they will be the same object
     *
     * @return
     */
    @SuppressWarnings(""unused"")
    protected static Map<String, HttpString> httpStrings() {
        final Map<String, HttpString> results = new HashMap<>();
        final Class[] classs = {Headers.class, Methods.class, Protocols.class};

        for (Class<?> c : classs) {
            for (Field field : c.getDeclaredFields()) {
                if (field.getType().equals(HttpString.class)) {
                    HttpString result = null;
                    try {
                        result = (HttpString) field.get(null);
                        results.put(result.toString(), result);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
        return results;

    }

    public static class BadRequestException extends Exception {
        public BadRequestException(String msg) {
            super(msg);
        }
    }

}
"
"core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java:[644,658]:handleHeaderValue","    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) throws BadRequestException {
        HttpString headerName = state.nextHeader;
        StringBuilder stringBuilder = state.stringBuilder;
        HashMap<HttpString, String> headerValuesCache = state.headerValuesCache;
        if (stringBuilder.length() == 0) {
            String existing = headerValuesCache.get(headerName);
            if (existing != null) {
                if (handleCachedHeader(existing, buffer, state, builder)) {
                    return;
                }
            }
        }

        handleHeaderValueCacheMiss(buffer, state, builder, headerName, headerValuesCache, stringBuilder);
    }
"
"core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java:[660,755]:handleHeaderValueCacheMiss","    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) throws BadRequestException {

        int parseState = state.parseState;
        while (buffer.hasRemaining() && parseState == NORMAL) {
            final byte next = buffer.get();
            if (next == '\r') {
                parseState = BEGIN_LINE_END;
            } else if (next == '\n') {
                parseState = LINE_END;
            } else if (next == ' ' || next == '\t') {
                parseState = WHITESPACE;
            } else {
                stringBuilder.append((char) (next & 0xFF));
            }
        }

        while (buffer.hasRemaining()) {
            final byte next = buffer.get();
            switch (parseState) {
                case NORMAL: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                        parseState = WHITESPACE;
                    } else {
                        stringBuilder.append((char) (next & 0xFF));
                    }
                    break;
                }
                case WHITESPACE: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                    } else {
                        if (stringBuilder.length() > 0) {
                            stringBuilder.append(' ');
                        }
                        stringBuilder.append((char) (next & 0xFF));
                        parseState = NORMAL;
                    }
                    break;
                }
                case LINE_END:
                case BEGIN_LINE_END: {
                    if (next == '\n' && parseState == BEGIN_LINE_END) {
                        parseState = LINE_END;
                    } else if (next == '\t' ||
                            next == ' ') {
                        //this is a continuation
                        parseState = WHITESPACE;
                    } else {
                        //we have a header
                        String headerValue = stringBuilder.toString();


                        if (++state.mapCount > maxHeaders) {
                            throw new BadRequestException(UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders));
                        }
                        //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
                        builder.getRequestHeaders().add(headerName, headerValue);
                        if(headerValuesCache.size() < maxHeaders) {
                            //we have a limit on how many we can cache
                            //to prevent memory filling and hash collision attacks
                            headerValuesCache.put(headerName, headerValue);
                        }

                        state.nextHeader = null;

                        state.leftOver = next;
                        state.stringBuilder.setLength(0);
                        if (next == '\r') {
                            parseState = AWAIT_DATA_END;
                        } else if (next == '\n') {
                            state.state = ParseState.PARSE_COMPLETE;
                            return;
                        } else {
                            state.state = ParseState.HEADER;
                            state.parseState = 0;
                            return;
                        }
                    }
                    break;
                }
                case AWAIT_DATA_END: {
                    state.state = ParseState.PARSE_COMPLETE;
                    return;
                }
            }
        }
        //we only write to the state if we did not finish parsing
        state.parseState = parseState;
    }
"
"core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java:[93,110]:HttpReadListener","    HttpReadListener(final HttpServerConnection connection, final HttpRequestParser parser, ConnectorStatisticsImpl connectorStatistics) {
        this.connection = connection;
        this.parser = parser;
        this.connectorStatistics = connectorStatistics;
        this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);
        this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
        this.recordRequestStartTime = connection.getUndertowOptions().get(UndertowOptions.RECORD_REQUEST_START_TIME, false);
        this.requireHostHeader = connection.getUndertowOptions().get(UndertowOptions.REQUIRE_HOST_HTTP11, false);
        this.allowUnknownProtocols = connection.getUndertowOptions().get(UndertowOptions.ALLOW_UNKNOWN_PROTOCOLS, false);
        int requestParseTimeout = connection.getUndertowOptions().get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);
        int requestIdleTimeout = connection.getUndertowOptions().get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);
        if(requestIdleTimeout < 0 && requestParseTimeout < 0) {
            this.parseTimeoutUpdater = null;
        } else {
            this.parseTimeoutUpdater = new ParseTimeoutUpdater(connection, requestParseTimeout, requestIdleTimeout);
            connection.addCloseListener(parseTimeoutUpdater);
        }
    }
"
