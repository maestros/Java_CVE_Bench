Vul_Path,Vul_Src
"weixin-java-common/src/test/java/me/chanjar/weixin/common/util/crypto/WxCryptUtilTest.java:[19,102]:WxCryptUtilTest","public class WxCryptUtilTest {
  String encodingAesKey = ""abcdefghijklmnopqrstuvwxyz0123456789ABCDEFG"";
  String token = ""pamtest"";
  String timestamp = ""1409304348"";
  String nonce = ""xxxxxx"";
  String appId = ""wxb11529c136998cb6"";
  String randomStr = ""aaaabbbbccccdddd"";

  String xmlFormat = ""<xml><ToUserName><![CDATA[toUser]]></ToUserName><Encrypt><![CDATA[%1$s]]></Encrypt></xml>"";
  String replyMsg = ""ææ¯ä¸­æabcd123"";

  String afterAesEncrypt = ""jn1L23DB+6ELqJ+6bruv21Y6MD7KeIfP82D6gU39rmkgczbWwt5+3bnyg5K55bgVtVzd832WzZGMhkP72vVOfg=="";

  String replyMsg2 = ""<xml><ToUserName><![CDATA[oia2Tjææ¯ä¸­æjewbmiOUlr6X-1crbLOvLw]]></ToUserName><FromUserName><![CDATA[gh_7f083739789a]]></FromUserName><CreateTime>1407743423</CreateTime><MsgType><![CDATA[video]]></MsgType><Video><MediaId><![CDATA[eYJ1MbwPRJtOvIEabaxHs7TX2D-HV71s79GUxqdUkjm6Gs2Ed1KF3ulAOA9H1xG0]]></MediaId><Title><![CDATA[testCallBackReplyVideo]]></Title><Description><![CDATA[testCallBackReplyVideo]]></Description></Video></xml>"";
  String afterAesEncrypt2 = ""jn1L23DB+6ELqJ+6bruv23M2GmYfkv0xBh2h+XTBOKVKcgDFHle6gqcZ1cZrk3e1qjPQ1F4RsLWzQRG9udbKWesxlkupqcEcW7ZQweImX9+wLMa0GaUzpkycA8+IamDBxn5loLgZpnS7fVAbExOkK5DYHBmv5tptA9tklE/fTIILHR8HLXa5nQvFb3tYPKAlHF3rtTeayNf0QuM+UW/wM9enGIDIJHF7CLHiDNAYxr+r+OrJCmPQyTy8cVWlu9iSvOHPT/77bZqJucQHQ04sq7KZI27OcqpQNSto2OdHCoTccjggX5Z9Mma0nMJBU+jLKJ38YB1fBIz+vBzsYjrTmFQ44YfeEuZ+xRTQwr92vhA9OxchWVINGC50qE/6lmkwWTwGX9wtQpsJKhP+oS7rvTY8+VdzETdfakjkwQ5/Xka042OlUb1/slTwo4RscuQ+RdxSGvDahxAJ6+EAjLt9d8igHngxIbf6YyqqROxuxqIeIch3CssH/LqRs+iAcILvApYZckqmA7FNERspKA5f8GoJ9sv8xmGvZ9Yrf57cExWtnX8aCMMaBropU/1k+hKP5LVdzbWCG0hGwx/dQudYR/eXp3P0XxjlFiy+9DMlaFExWUZQDajPkdPrEeOwofJb"";

  public void testNormal() throws ParserConfigurationException, SAXException, IOException {
    WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
    String encryptedXml = pc.encrypt(this.replyMsg);

    System.out.println(encryptedXml);

    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
    Document document = documentBuilder.parse(new InputSource(new StringReader(encryptedXml)));

    Element root = document.getDocumentElement();
    String cipherText = root.getElementsByTagName(""Encrypt"").item(0).getTextContent();
    System.out.println(cipherText);

    String msgSignature = root.getElementsByTagName(""MsgSignature"").item(0).getTextContent();
    System.out.println(msgSignature);

    String timestamp = root.getElementsByTagName(""TimeStamp"").item(0).getTextContent();
    System.out.println(timestamp);

    String nonce = root.getElementsByTagName(""Nonce"").item(0).getTextContent();
    System.out.println(nonce);

    String messageText = String.format(this.xmlFormat, cipherText);
    System.out.println(messageText);

    // ç¬¬ä¸æ¹æ¶å°ä¼ä¸å·å¹³å°åéçæ¶æ¯
    String plainMessage = pc.decrypt(cipherText);
    System.out.println(plainMessage);

    assertEquals(plainMessage, this.replyMsg);
  }

  public void testAesEncrypt() {
    WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
    assertEquals(pc.encrypt(this.randomStr, this.replyMsg), this.afterAesEncrypt);
  }

  public void testAesEncrypt2() {
    WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
    assertEquals(pc.encrypt(this.randomStr, this.replyMsg2), this.afterAesEncrypt2);
  }

  public void testValidateSignatureError() throws ParserConfigurationException, SAXException,
    IOException {
    try {
      WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
      String afterEncrpt = pc.encrypt(this.replyMsg);
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      StringReader sr = new StringReader(afterEncrpt);
      InputSource is = new InputSource(sr);
      Document document = db.parse(is);

      Element root = document.getDocumentElement();
      NodeList nodelist1 = root.getElementsByTagName(""Encrypt"");

      String encrypt = nodelist1.item(0).getTextContent();
      String fromXML = String.format(this.xmlFormat, encrypt);
      pc.decrypt(""12345"", this.timestamp, this.nonce, fromXML); // è¿éç­¾åéè¯¯
    } catch (RuntimeException e) {
      assertEquals(e.getMessage(), ""å å¯æ¶æ¯ç­¾åæ ¡éªå¤±è´¥"");
      return;
    }
    fail(""éè¯¯æµç¨ä¸æåºå¼å¸¸ï¼ï¼ï¼"");
  }

}
"
"weixin-java-common/src/test/java/me/chanjar/weixin/common/util/crypto/WxCryptUtilTest.java:[35,66]:testNormal","  public void testNormal() throws ParserConfigurationException, SAXException, IOException {
    WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
    String encryptedXml = pc.encrypt(this.replyMsg);

    System.out.println(encryptedXml);

    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
    Document document = documentBuilder.parse(new InputSource(new StringReader(encryptedXml)));

    Element root = document.getDocumentElement();
    String cipherText = root.getElementsByTagName(""Encrypt"").item(0).getTextContent();
    System.out.println(cipherText);

    String msgSignature = root.getElementsByTagName(""MsgSignature"").item(0).getTextContent();
    System.out.println(msgSignature);

    String timestamp = root.getElementsByTagName(""TimeStamp"").item(0).getTextContent();
    System.out.println(timestamp);

    String nonce = root.getElementsByTagName(""Nonce"").item(0).getTextContent();
    System.out.println(nonce);

    String messageText = String.format(this.xmlFormat, cipherText);
    System.out.println(messageText);

    // ç¬¬ä¸æ¹æ¶å°ä¼ä¸å·å¹³å°åéçæ¶æ¯
    String plainMessage = pc.decrypt(cipherText);
    System.out.println(plainMessage);

    assertEquals(plainMessage, this.replyMsg);
  }
"
"weixin-java-common/src/test/java/me/chanjar/weixin/common/util/crypto/WxCryptUtilTest.java:[78,100]:testValidateSignatureError","  public void testValidateSignatureError() throws ParserConfigurationException, SAXException,
    IOException {
    try {
      WxCryptUtil pc = new WxCryptUtil(this.token, this.encodingAesKey, this.appId);
      String afterEncrpt = pc.encrypt(this.replyMsg);
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      StringReader sr = new StringReader(afterEncrpt);
      InputSource is = new InputSource(sr);
      Document document = db.parse(is);

      Element root = document.getDocumentElement();
      NodeList nodelist1 = root.getElementsByTagName(""Encrypt"");

      String encrypt = nodelist1.item(0).getTextContent();
      String fromXML = String.format(this.xmlFormat, encrypt);
      pc.decrypt(""12345"", this.timestamp, this.nonce, fromXML); // è¿éç­¾åéè¯¯
    } catch (RuntimeException e) {
      assertEquals(e.getMessage(), ""å å¯æ¶æ¯ç­¾åæ ¡éªå¤±è´¥"");
      return;
    }
    fail(""éè¯¯æµç¨ä¸æåºå¼å¸¸ï¼ï¼ï¼"");
  }
"
"weixin-java-common/src/main/java/me/chanjar/weixin/common/util/crypto/WxCryptUtil.java:[29,282]:WxCryptUtil","public class WxCryptUtil {

  private static final Base64 BASE64 = new Base64();
  private static final Charset CHARSET = StandardCharsets.UTF_8;

  private static final ThreadLocal<DocumentBuilder> BUILDER_LOCAL = new ThreadLocal<DocumentBuilder>() {
    @Override
    protected DocumentBuilder initialValue() {
      try {
        return DocumentBuilderFactory.newInstance().newDocumentBuilder();
      } catch (ParserConfigurationException exc) {
        throw new IllegalArgumentException(exc);
      }
    }
  };

  protected byte[] aesKey;
  protected String token;
  protected String appidOrCorpid;

  public WxCryptUtil() {
  }

  /**
   * æé å½æ°
   *
   * @param token          å¬ä¼å¹³å°ä¸ï¼å¼åèè®¾ç½®çtoken
   * @param encodingAesKey å¬ä¼å¹³å°ä¸ï¼å¼åèè®¾ç½®çEncodingAESKey
   * @param appidOrCorpid  å¬ä¼å¹³å°appid/corpid
   */
  public WxCryptUtil(String token, String encodingAesKey,
                     String appidOrCorpid) {
    this.token = token;
    this.appidOrCorpid = appidOrCorpid;
    this.aesKey = Base64.decodeBase64(encodingAesKey + ""="");
  }

  static String extractEncryptPart(String xml) {
    try {
      DocumentBuilder db = BUILDER_LOCAL.get();
      Document document = db.parse(new InputSource(new StringReader(xml)));

      Element root = document.getDocumentElement();
      return root.getElementsByTagName(""Encrypt"").item(0).getTextContent();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * å°ä¸ä¸ªæ°å­è½¬æ¢æçæ4ä¸ªå­èçç½ç»å­èåºbytesæ°ç»
   */
  private static byte[] number2BytesInNetworkOrder(int number) {
    byte[] orderBytes = new byte[4];
    orderBytes[3] = (byte) (number & 0xFF);
    orderBytes[2] = (byte) (number >> 8 & 0xFF);
    orderBytes[1] = (byte) (number >> 16 & 0xFF);
    orderBytes[0] = (byte) (number >> 24 & 0xFF);
    return orderBytes;
  }

  /**
   * 4ä¸ªå­èçç½ç»å­èåºbytesæ°ç»è¿åæä¸ä¸ªæ°å­
   */
  private static int bytesNetworkOrder2Number(byte[] bytesInNetworkOrder) {
    int sourceNumber = 0;
    for (int i = 0; i < 4; i++) {
      sourceNumber <<= 8;
      sourceNumber |= bytesInNetworkOrder[i] & 0xff;
    }
    return sourceNumber;
  }

  /**
   * éæºçæ16ä½å­ç¬¦ä¸²
   */
  private static String genRandomStr() {
    String base = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"";
    Random random = new Random();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 16; i++) {
      int number = random.nextInt(base.length());
      sb.append(base.charAt(number));
    }
    return sb.toString();
  }

  /**
   * çæxmlæ¶æ¯
   *
   * @param encrypt   å å¯åçæ¶æ¯å¯æ
   * @param signature å®å¨ç­¾å
   * @param timestamp æ¶é´æ³
   * @param nonce     éæºå­ç¬¦ä¸²
   * @return çæçxmlå­ç¬¦ä¸²
   */
  private static String generateXml(String encrypt, String signature,
                                    String timestamp, String nonce) {
    String format = ""<xml>\n"" + ""<Encrypt><![CDATA[%1$s]]></Encrypt>\n""
      + ""<MsgSignature><![CDATA[%2$s]]></MsgSignature>\n""
      + ""<TimeStamp>%3$s</TimeStamp>\n"" + ""<Nonce><![CDATA[%4$s]]></Nonce>\n""
      + ""</xml>"";
    return String.format(format, encrypt, signature, timestamp, nonce);
  }

  /**
   * å°å¬ä¼å¹³å°åå¤ç¨æ·çæ¶æ¯å å¯æå.
   * <ol>
   * <li>å¯¹è¦åéçæ¶æ¯è¿è¡AES-CBCå å¯</li>
   * <li>çæå®å¨ç­¾å</li>
   * <li>å°æ¶æ¯å¯æåå®å¨ç­¾åæåæxmlæ ¼å¼</li>
   * </ol>
   *
   * @param plainText å¬ä¼å¹³å°å¾åå¤ç¨æ·çæ¶æ¯ï¼xmlæ ¼å¼çå­ç¬¦ä¸²
   * @return å å¯åçå¯ä»¥ç´æ¥åå¤ç¨æ·çå¯æï¼åæ¬msg_signature, timestamp, nonce, encryptçxmlæ ¼å¼çå­ç¬¦ä¸²
   */
  public String encrypt(String plainText) {
    // å å¯
    String encryptedXml = encrypt(genRandomStr(), plainText);

    // çæå®å¨ç­¾å
    String timeStamp = Long.toString(System.currentTimeMillis() / 1000L);
    String nonce = genRandomStr();

    String signature = SHA1.gen(this.token, timeStamp, nonce, encryptedXml);
    return generateXml(encryptedXml, signature, timeStamp, nonce);
  }

  /**
   * å¯¹ææè¿è¡å å¯.
   *
   * @param plainText éè¦å å¯çææ
   * @return å å¯åbase64ç¼ç çå­ç¬¦ä¸²
   */
  protected String encrypt(String randomStr, String plainText) {
    ByteGroup byteCollector = new ByteGroup();
    byte[] randomStringBytes = randomStr.getBytes(CHARSET);
    byte[] plainTextBytes = plainText.getBytes(CHARSET);
    byte[] bytesOfSizeInNetworkOrder = number2BytesInNetworkOrder(
      plainTextBytes.length);
    byte[] appIdBytes = this.appidOrCorpid.getBytes(CHARSET);

    // randomStr + networkBytesOrder + text + appid
    byteCollector.addBytes(randomStringBytes);
    byteCollector.addBytes(bytesOfSizeInNetworkOrder);
    byteCollector.addBytes(plainTextBytes);
    byteCollector.addBytes(appIdBytes);

    // ... + pad: ä½¿ç¨èªå®ä¹çå¡«åæ¹å¼å¯¹ææè¿è¡è¡¥ä½å¡«å
    byte[] padBytes = PKCS7Encoder.encode(byteCollector.size());
    byteCollector.addBytes(padBytes);

    // è·å¾æç»çå­èæµ, æªå å¯
    byte[] unencrypted = byteCollector.toBytes();

    try {
      // è®¾ç½®å å¯æ¨¡å¼ä¸ºAESçCBCæ¨¡å¼
      Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
      SecretKeySpec keySpec = new SecretKeySpec(this.aesKey, ""AES"");
      IvParameterSpec iv = new IvParameterSpec(this.aesKey, 0, 16);
      cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);

      // å å¯
      byte[] encrypted = cipher.doFinal(unencrypted);

      // ä½¿ç¨BASE64å¯¹å å¯åçå­ç¬¦ä¸²è¿è¡ç¼ç 
      return BASE64.encodeToString(encrypted);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * æ£éªæ¶æ¯ççå®æ§ï¼å¹¶ä¸è·åè§£å¯åçææ.
   * <ol>
   * <li>å©ç¨æ¶å°çå¯æçæå®å¨ç­¾åï¼è¿è¡ç­¾åéªè¯</li>
   * <li>è¥éªè¯éè¿ï¼åæåxmlä¸­çå å¯æ¶æ¯</li>
   * <li>å¯¹æ¶æ¯è¿è¡è§£å¯</li>
   * </ol>
   *
   * @param msgSignature ç­¾åä¸²ï¼å¯¹åºURLåæ°çmsg_signature
   * @param timeStamp    æ¶é´æ³ï¼å¯¹åºURLåæ°çtimestamp
   * @param nonce        éæºä¸²ï¼å¯¹åºURLåæ°çnonce
   * @param encryptedXml å¯æï¼å¯¹åºPOSTè¯·æ±çæ°æ®
   * @return è§£å¯åçåæ
   */
  public String decrypt(String msgSignature, String timeStamp, String nonce, String encryptedXml) {
    // å¯é¥ï¼å¬ä¼è´¦å·çapp corpSecret
    // æåå¯æ
    String cipherText = extractEncryptPart(encryptedXml);

    // éªè¯å®å¨ç­¾å
    String signature = SHA1.gen(this.token, timeStamp, nonce, cipherText);
    if (!signature.equals(msgSignature)) {
      throw new RuntimeException(""å å¯æ¶æ¯ç­¾åæ ¡éªå¤±è´¥"");
    }

    // è§£å¯
    return decrypt(cipherText);
  }

  /**
   * å¯¹å¯æè¿è¡è§£å¯.
   *
   * @param cipherText éè¦è§£å¯çå¯æ
   * @return è§£å¯å¾å°çææ
   */
  public String decrypt(String cipherText) {
    byte[] original;
    try {
      // è®¾ç½®è§£å¯æ¨¡å¼ä¸ºAESçCBCæ¨¡å¼
      Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
      SecretKeySpec key_spec = new SecretKeySpec(this.aesKey, ""AES"");
      IvParameterSpec iv = new IvParameterSpec(
        Arrays.copyOfRange(this.aesKey, 0, 16));
      cipher.init(Cipher.DECRYPT_MODE, key_spec, iv);

      // ä½¿ç¨BASE64å¯¹å¯æè¿è¡è§£ç 
      byte[] encrypted = Base64.decodeBase64(cipherText);

      // è§£å¯
      original = cipher.doFinal(encrypted);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }

    String xmlContent, from_appid;
    try {
      // å»é¤è¡¥ä½å­ç¬¦
      byte[] bytes = PKCS7Encoder.decode(original);

      // åç¦»16ä½éæºå­ç¬¦ä¸²,ç½ç»å­èåºåAppId
      byte[] networkOrder = Arrays.copyOfRange(bytes, 16, 20);

      int xmlLength = bytesNetworkOrder2Number(networkOrder);

      xmlContent = new String(Arrays.copyOfRange(bytes, 20, 20 + xmlLength),
        CHARSET);
      from_appid = new String(
        Arrays.copyOfRange(bytes, 20 + xmlLength, bytes.length), CHARSET);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }

    // appidä¸ç¸åçæåµ
    if (!from_appid.equals(this.appidOrCorpid)) {
      throw new RuntimeException(""AppIDä¸æ­£ç¡®"");
    }

    return xmlContent;

  }

}
"
"weixin-java-common/src/main/java/me/chanjar/weixin/common/util/crypto/WxCryptUtil.java:[34,43]:BUILDER_LOCAL","  private static final ThreadLocal<DocumentBuilder> BUILDER_LOCAL = new ThreadLocal<DocumentBuilder>() {
    @Override
    protected DocumentBuilder initialValue() {
      try {
        return DocumentBuilderFactory.newInstance().newDocumentBuilder();
      } catch (ParserConfigurationException exc) {
        throw new IllegalArgumentException(exc);
      }
    }
  };
"
"weixin-java-pay/src/main/java/com/github/binarywang/wxpay/bean/result/BaseWxPayResult.java:[186,201]:getXmlDoc","  private Document getXmlDoc() {
    if (this.xmlDoc != null) {
      return this.xmlDoc;
    }

    try {
      this.xmlDoc = DocumentBuilderFactory
        .newInstance()
        .newDocumentBuilder()
        .parse(new ByteArrayInputStream(this.xmlString.getBytes(""UTF-8"")));
      return xmlDoc;
    } catch (SAXException | IOException | ParserConfigurationException e) {
      throw new RuntimeException(""éæ³çxmlææ¬åå®¹ï¼"" + this.xmlString);
    }

  }
"
