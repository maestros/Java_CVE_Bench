Vul_Path,Vul_Src
"core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java:[168,171]:AjpRequestParser","    public AjpRequestParser(String encoding, boolean doDecode) {
        this.encoding = encoding;
        this.doDecode = doDecode;
    }
"
"core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java:[174,403]:parse","    public void parse(final ByteBuffer buf, final AjpRequestParseState state, final HttpServerExchange exchange) throws IOException {
        if (!buf.hasRemaining()) {
            return;
        }
        switch (state.state) {
            case AjpRequestParseState.BEGIN: {
                IntegerHolder result = parse16BitInteger(buf, state);
                if (!result.readComplete) {
                    return;
                } else {
                    if (result.value != 0x1234) {
                        throw new IllegalStateException(""Wrong magic number"");
                    }
                }
            }
            case AjpRequestParseState.READING_DATA_SIZE: {
                IntegerHolder result = parse16BitInteger(buf, state);
                if (!result.readComplete) {
                    state.state = AjpRequestParseState.READING_DATA_SIZE;
                    return;
                } else {
                    state.dataSize = result.value;
                }
            }
            case AjpRequestParseState.READING_PREFIX_CODE: {
                if (!buf.hasRemaining()) {
                    state.state = AjpRequestParseState.READING_PREFIX_CODE;
                    return;
                } else {
                    final byte prefix = buf.get();
                    state.prefix = prefix;
                    if (prefix != 2) {
                        state.state = AjpRequestParseState.DONE;
                        return;
                    }
                }
            }
            case AjpRequestParseState.READING_METHOD: {
                if (!buf.hasRemaining()) {
                    state.state = AjpRequestParseState.READING_METHOD;
                    return;
                } else {
                    int method = buf.get();
                    if (method > 0 && method < 28) {
                        exchange.setRequestMethod(HTTP_METHODS[method]);
                    } else if((method & 0xFF) != 0xFF) {
                        throw new IllegalArgumentException(""Unknown method type "" + method);
                    }
                }
            }
            case AjpRequestParseState.READING_PROTOCOL: {
                StringHolder result = parseString(buf, state, false);
                if (result.readComplete) {
                    //TODO: more efficient way of doing this
                    exchange.setProtocol(HttpString.tryFromString(result.value));
                } else {
                    state.state = AjpRequestParseState.READING_PROTOCOL;
                    return;
                }
            }
            case AjpRequestParseState.READING_REQUEST_URI: {
                StringHolder result = parseString(buf, state, false);
                if (result.readComplete) {
                    int colon = result.value.indexOf(';');
                    if (colon == -1) {
                        String res = decode(result.value, result.containsUrlCharacters);
                        exchange.setRequestURI(result.value);
                        exchange.setRequestPath(res);
                        exchange.setRelativePath(res);
                    } else {
                        final String url = result.value.substring(0, colon);
                        String res = decode(url, result.containsUrlCharacters);
                        exchange.setRequestURI(result.value);
                        exchange.setRequestPath(res);
                        exchange.setRelativePath(res);
                        URLUtils.parsePathParms(result.value.substring(colon + 1), exchange, encoding, doDecode && result.containsUrlCharacters);
                    }
                } else {
                    state.state = AjpRequestParseState.READING_REQUEST_URI;
                    return;
                }
            }
            case AjpRequestParseState.READING_REMOTE_ADDR: {
                StringHolder result = parseString(buf, state, false);
                if (result.readComplete) {
                    state.remoteAddress = result.value;
                } else {
                    state.state = AjpRequestParseState.READING_REMOTE_ADDR;
                    return;
                }
            }
            case AjpRequestParseState.READING_REMOTE_HOST: {
                StringHolder result = parseString(buf, state, false);
                if (result.readComplete) {
                    //exchange.setRequestURI(result.value);
                } else {
                    state.state = AjpRequestParseState.READING_REMOTE_HOST;
                    return;
                }
            }
            case AjpRequestParseState.READING_SERVER_NAME: {
                StringHolder result = parseString(buf, state, false);
                if (result.readComplete) {
                    state.serverAddress = result.value;
                } else {
                    state.state = AjpRequestParseState.READING_SERVER_NAME;
                    return;
                }
            }
            case AjpRequestParseState.READING_SERVER_PORT: {
                IntegerHolder result = parse16BitInteger(buf, state);
                if (result.readComplete) {
                    state.serverPort = result.value;
                } else {
                    state.state = AjpRequestParseState.READING_SERVER_PORT;
                    return;
                }
            }
            case AjpRequestParseState.READING_IS_SSL: {
                if (!buf.hasRemaining()) {
                    state.state = AjpRequestParseState.READING_IS_SSL;
                    return;
                } else {
                    final byte isSsl = buf.get();
                    if (isSsl != 0) {
                        exchange.setRequestScheme(""https"");
                    } else {
                        exchange.setRequestScheme(""http"");
                    }
                }
            }
            case AjpRequestParseState.READING_NUM_HEADERS: {
                IntegerHolder result = parse16BitInteger(buf, state);
                if (!result.readComplete) {
                    state.state = AjpRequestParseState.READING_NUM_HEADERS;
                    return;
                } else {
                    state.numHeaders = result.value;
                }
            }
            case AjpRequestParseState.READING_HEADERS: {
                int readHeaders = state.readHeaders;
                while (readHeaders < state.numHeaders) {
                    if (state.currentHeader == null) {
                        StringHolder result = parseString(buf, state, true);
                        if (!result.readComplete) {
                            state.state = AjpRequestParseState.READING_HEADERS;
                            state.readHeaders = readHeaders;
                            return;
                        }
                        if (result.header != null) {
                            state.currentHeader = result.header;
                        } else {
                            state.currentHeader = HttpString.tryFromString(result.value);
                        }
                    }
                    StringHolder result = parseString(buf, state, false);
                    if (!result.readComplete) {
                        state.state = AjpRequestParseState.READING_HEADERS;
                        state.readHeaders = readHeaders;
                        return;
                    }
                    exchange.getRequestHeaders().add(state.currentHeader, result.value);
                    state.currentHeader = null;
                    ++readHeaders;
                }
            }
            case AjpRequestParseState.READING_ATTRIBUTES: {
                for (; ; ) {
                    if (state.currentAttribute == null && state.currentIntegerPart == -1) {
                        if (!buf.hasRemaining()) {
                            state.state = AjpRequestParseState.READING_ATTRIBUTES;
                            return;
                        }
                        int val = (0xFF & buf.get());
                        if (val == 0xFF) {
                            state.state = AjpRequestParseState.DONE;
                            return;
                        } else if (val == 0x0A) {
                            //we need to read the name. We overload currentIntegerPart to avoid adding another state field
                            state.currentIntegerPart = 1;
                        } else {
                            state.currentAttribute = ATTRIBUTES[val];
                        }
                    }
                    if (state.currentIntegerPart == 1) {
                        StringHolder result = parseString(buf, state, false);
                        if (!result.readComplete) {
                            state.state = AjpRequestParseState.READING_ATTRIBUTES;
                            return;
                        }
                        state.currentAttribute = result.value;
                        state.currentIntegerPart = -1;
                    }
                    String result;
                    if (state.currentAttribute.equals(SSL_KEY_SIZE)) {
                        IntegerHolder resultHolder = parse16BitInteger(buf, state);
                        if (!resultHolder.readComplete) {
                            state.state = AjpRequestParseState.READING_ATTRIBUTES;
                            return;
                        }
                        result = Integer.toString(resultHolder.value);
                    } else {
                        StringHolder resultHolder = parseString(buf, state, false);
                        if (!resultHolder.readComplete) {
                            state.state = AjpRequestParseState.READING_ATTRIBUTES;
                            return;
                        }
                        result = resultHolder.value;
                    }
                    //query string.
                    if (state.currentAttribute.equals(QUERY_STRING)) {
                        exchange.setQueryString(result == null ? """" : result);
                        URLUtils.parseQueryString(result, exchange, encoding, doDecode);
                    } else if (state.currentAttribute.equals(REMOTE_USER)) {
                        exchange.putAttachment(ExternalAuthenticationMechanism.EXTERNAL_PRINCIPAL, result);
                    } else if (state.currentAttribute.equals(AUTH_TYPE)) {
                        exchange.putAttachment(ExternalAuthenticationMechanism.EXTERNAL_AUTHENTICATION_TYPE, result);
                    } else if (state.currentAttribute.equals(STORED_METHOD)) {
                        exchange.setRequestMethod(new HttpString(result));
                    } else {
                        //other attributes
                        state.attributes.put(state.currentAttribute, result);
                    }
                    state.currentAttribute = null;
                }
            }
        }
        state.state = AjpRequestParseState.DONE;
    }
"
"core/src/main/java/io/undertow/UndertowMessages.java:[38,369]:UndertowMessages","public interface UndertowMessages {

    UndertowMessages MESSAGES = Messages.getBundle(UndertowMessages.class);

    @Message(id = 1, value = ""Maximum concurrent requests must be larger than zero."")
    IllegalArgumentException maximumConcurrentRequestsMustBeLargerThanZero();

    @Message(id = 2, value = ""The response has already been started"")
    IllegalStateException responseAlreadyStarted();

    // id = 3

    @Message(id = 4, value = ""getResponseChannel() has already been called"")
    IllegalStateException responseChannelAlreadyProvided();

    @Message(id = 5, value = ""getRequestChannel() has already been called"")
    IllegalStateException requestChannelAlreadyProvided();

    // id = 6

    // id = 7

    @Message(id = 8, value = ""Handler cannot be null"")
    IllegalArgumentException handlerCannotBeNull();

    @Message(id = 9, value = ""Path must be specified"")
    IllegalArgumentException pathMustBeSpecified();

    @Message(id = 10, value = ""Session not found %s"")
    IllegalStateException sessionNotFound(final String session);

    @Message(id = 11, value = ""Session manager must not be null"")
    IllegalStateException sessionManagerMustNotBeNull();

    @Message(id = 12, value = ""Session manager was not attached to the request. Make sure that the SessionAttachmentHander is installed in the handler chain"")
    IllegalStateException sessionManagerNotFound();

    @Message(id = 13, value = ""Argument %s cannot be null"")
    IllegalArgumentException argumentCannotBeNull(final String argument);

    @Message(id = 14, value = ""close() called with data still to be flushed. Please call shutdownWrites() and then call flush() until it returns true before calling close()"")
    IOException closeCalledWithDataStillToBeFlushed();

    @Message(id = 16, value = ""Could not add cookie as cookie handler was not present in the handler chain"")
    IllegalStateException cookieHandlerNotPresent();

    @Message(id = 17, value = ""Form value is a file, use getFile() instead"")
    IllegalStateException formValueIsAFile();

    @Message(id = 18, value = ""Form value is a String, use getValue() instead"")
    IllegalStateException formValueIsAString();

    @Message(id = 19, value = ""Connection from %s terminated as request entity was larger than %s"")
    IOException requestEntityWasTooLarge(SocketAddress address, long size);

    @Message(id = 20, value = ""Connection terminated as request was larger than %s"")
    IOException requestEntityWasTooLarge(long size);

    @Message(id = 21, value = ""Session already invalidated"")
    IllegalStateException sessionAlreadyInvalidated();

    @Message(id = 22, value = ""The specified hash algorithm '%s' can not be found."")
    IllegalArgumentException hashAlgorithmNotFound(String algorithmName);

    @Message(id = 23, value = ""An invalid Base64 token has been received."")
    IllegalArgumentException invalidBase64Token(@Cause final IOException cause);

    @Message(id = 24, value = ""An invalidly formatted nonce has been received."")
    IllegalArgumentException invalidNonceReceived();

    @Message(id = 25, value = ""Unexpected token '%s' within header."")
    IllegalArgumentException unexpectedTokenInHeader(final String name);

    @Message(id = 26, value = ""Invalid header received."")
    IllegalArgumentException invalidHeader();

    @Message(id = 27, value = ""Could not find session cookie config in the request"")
    IllegalStateException couldNotFindSessionCookieConfig();

    @Message(id = 28, value = ""Session %s already exists"")
    IllegalStateException sessionAlreadyExists(final String id);

    @Message(id = 29, value = ""Channel was closed mid chunk, if you have attempted to write chunked data you cannot shutdown the channel until after it has all been written."")
    IOException chunkedChannelClosedMidChunk();

    @Message(id = 30, value = ""User %s successfully authenticated."")
    String userAuthenticated(final String userName);

    @Message(id = 31, value = ""User %s has logged out."")
    String userLoggedOut(final String userName);

    @Message(id = 33, value = ""Authentication type %s cannot be combined with %s"")
    IllegalStateException authTypeCannotBeCombined(String type, String existing);

    @Message(id = 34, value = ""Stream is closed"")
    IOException streamIsClosed();

    @Message(id = 35, value = ""Cannot get stream as startBlocking has not been invoked"")
    IllegalStateException startBlockingHasNotBeenCalled();

    @Message(id = 36, value = ""Connection terminated parsing multipart data"")
    IOException connectionTerminatedReadingMultiPartData();

    @Message(id = 37, value = ""Failed to parse path in HTTP request"")
    RuntimeException failedToParsePath();

    @Message(id = 38, value = ""Authentication failed, requested user name '%s'"")
    String authenticationFailed(final String userName);

    @Message(id = 39, value = ""To many query parameters, cannot have more than %s query parameters"")
    RuntimeException tooManyQueryParameters(int noParams);

    @Message(id = 40, value = ""To many headers, cannot have more than %s header"")
    RuntimeException tooManyHeaders(int noParams);

    @Message(id = 41, value = ""Channel is closed"")
    ClosedChannelException channelIsClosed();

    @Message(id = 42, value = ""Could not decode trailers in HTTP request"")
    IOException couldNotDecodeTrailers();

    @Message(id = 43, value = ""Data is already being sent. You must wait for the completion callback to be be invoked before calling send() again"")
    IllegalStateException dataAlreadyQueued();

    @Message(id = 44, value = ""More than one predicate with name %s. Builder class %s and %s"")
    IllegalStateException moreThanOnePredicateWithName(String name, Class<? extends PredicateBuilder> aClass, Class<? extends PredicateBuilder> existing);

    @Message(id = 45, value = ""Error parsing predicate string %s:%n%s"")
    IllegalArgumentException errorParsingPredicateString(String reason, String s);

    @Message(id = 46, value = ""The number of cookies sent exceeded the maximum of %s"")
    IllegalStateException tooManyCookies(int maxCookies);

    @Message(id = 47, value = ""The number of parameters exceeded the maximum of %s"")
    IllegalStateException tooManyParameters(int maxValues);

    @Message(id = 48, value = ""No request is currently active"")
    IllegalStateException noRequestActive();

    @Message(id = 50, value = ""AuthenticationMechanism Outcome is null"")
    IllegalStateException authMechanismOutcomeNull();

    @Message(id = 51, value = ""Not a valid IP pattern %s"")
    IllegalArgumentException notAValidIpPattern(String peer);

    @Message(id = 52, value = ""Session data requested when non session based authentication in use"")
    IllegalStateException noSessionData();

    @Message(id = 53, value = ""Listener %s already registered"")
    IllegalArgumentException listenerAlreadyRegistered(String name);

    @Message(id = 54, value = ""The maximum size %s for an individual file in a multipart request was exceeded"")
    IOException maxFileSizeExceeded(long maxIndividualFileSize);

    @Message(id = 55, value = ""Could not set attribute %s to %s as it is read only"")
    String couldNotSetAttribute(String attributeName, String newValue);

    @Message(id = 56, value = ""Could not parse URI template %s, exception at char %s"")
    RuntimeException couldNotParseUriTemplate(String path, int i);

    @Message(id = 57, value = ""Mismatched braces in attribute string %s"")
    RuntimeException mismatchedBraces(String valueString);

    @Message(id = 58, value = ""More than one handler with name %s. Builder class %s and %s"")
    IllegalStateException moreThanOneHandlerWithName(String name, Class<? extends HandlerBuilder> aClass, Class<? extends HandlerBuilder> existing);

    @Message(id = 59, value = ""Invalid syntax %s"")
    IllegalArgumentException invalidSyntax(String line);

    @Message(id = 60, value = ""Error parsing handler string %s:%n%s"")
    IllegalArgumentException errorParsingHandlerString(String reason, String s);

    @Message(id = 61, value = ""Out of band responses only allowed for 100-continue requests"")
    IllegalArgumentException outOfBandResponseOnlyAllowedFor100Continue();

    @Message(id = 62, value = ""AJP does not support HTTP upgrade"")
    IllegalStateException ajpDoesNotSupportHTTPUpgrade();

    @Message(id = 63, value = ""File system watcher already started"")
    IllegalStateException fileSystemWatcherAlreadyStarted();

    @Message(id = 64, value = ""File system watcher not started"")
    IllegalStateException fileSystemWatcherNotStarted();

    @Message(id = 65, value = ""SSL must be specified to connect to a https URL"")
    IOException sslWasNull();

    @Message(id = 66, value = ""Incorrect magic number for AJP packet header"")
    IOException wrongMagicNumber();

    @Message(id = 67, value = ""No client cert was provided"")
    SSLPeerUnverifiedException peerUnverified();

    @Message(id = 68, value = ""Servlet path match failed"")
    IllegalArgumentException servletPathMatchFailed();

    @Message(id = 69, value = ""Could not parse set cookie header %s"")
    IllegalArgumentException couldNotParseCookie(String headerValue);

    @Message(id = 70, value = ""method can only be called by IO thread"")
    IllegalStateException canOnlyBeCalledByIoThread();

    @Message(id = 71, value = ""Cannot add path template %s, matcher already contains an equivalent pattern %s"")
    IllegalStateException matcherAlreadyContainsTemplate(String templateString, String templateString1);

    @Message(id = 72, value = ""Failed to decode url %s to charset %s"")
    IllegalArgumentException failedToDecodeURL(String s, String enc);

    @Message(id = 73, value = ""Resource change listeners are not supported"")
    IllegalArgumentException resourceChangeListenerNotSupported();

    @Message(id = 74, value = ""Could not renegotiate SSL connection to require client certificate, as client had sent more data"")
    IllegalStateException couldNotRenegotiate();

    @Message(id = 75, value = ""Object was freed"")
    IllegalStateException objectWasFreed();

    @Message(id = 76, value = ""Handler not shutdown"")
    IllegalStateException handlerNotShutdown();

    @Message(id = 77, value = ""The underlying transport does not support HTTP upgrade"")
    IllegalStateException upgradeNotSupported();

    @Message(id = 78, value = ""Renegotiation not supported"")
    IOException renegotiationNotSupported();

    @Message(id = 79, value = ""Not a valid user agent pattern %s"")
    IllegalArgumentException notAValidUserAgentPattern(String userAgent);

    @Message(id = 80, value = ""Not a valid regular expression pattern %s"")
    IllegalArgumentException notAValidRegularExpressionPattern(String pattern);

    @Message(id = 81, value = ""Bad request"")
    RuntimeException badRequest();

    @Message(id = 82, value = ""Host %s already registered"")
    RuntimeException hostAlreadyRegistered(Object host);

    @Message(id = 83, value = ""Host %s has not been registered"")
    RuntimeException hostHasNotBeenRegistered(Object host);

    @Message(id = 84, value = ""Attempted to write additional data after the last chunk"")
    IOException extraDataWrittenAfterChunkEnd();

    @Message(id = 85, value = ""Could not generate unique session id"")
    RuntimeException couldNotGenerateUniqueSessionId();

    @Message(id = 86, value = ""SPDY needs to be provided with a heap buffer pool, for use in compressing and decompressing headers."")
    IllegalArgumentException mustProvideHeapBuffer();

    @Message(id = 87, value = ""Unexpected SPDY frame type %s"")
    IOException unexpectedFrameType(int type);

    @Message(id = 88, value = ""SPDY control frames cannot have body content"")
    IOException controlFrameCannotHaveBodyContent();

    @Message(id = 89, value = ""SPDY not supported"")
    IOException spdyNotSupported();

    @Message(id = 90, value = ""Jetty NPN not available"")
    IOException jettyNPNNotAvailable();

    @Message(id = 91, value = ""Buffer has already been freed"")
    IllegalStateException bufferAlreadyFreed();

    @Message(id = 92, value = ""A SPDY header was too large to fit in a response buffer, if you want to support larger headers please increase the buffer size"")
    IllegalStateException headersTooLargeToFitInHeapBuffer();

    @Message(id = 93, value = ""A SPDY stream was reset by the remote endpoint"")
    IOException spdyStreamWasReset();

    @Message(id = 94, value = ""Blocking await method called from IO thread. Blocking IO must be dispatched to a worker thread or deadlocks will result."")
    IOException awaitCalledFromIoThread();

    @Message(id = 95, value = ""Recursive call to flushSenders()"")
    RuntimeException recursiveCallToFlushingSenders();

    @Message(id = 96, value = ""More data was written to the channel than specified in the content-length"")
    IllegalStateException fixedLengthOverflow();

    @Message(id = 97, value = ""AJP request already in progress"")
    IllegalStateException ajpRequestAlreadyInProgress();

    @Message(id = 98, value = ""HTTP ping data must be 8 bytes in length"")
    IllegalArgumentException httpPingDataMustBeLength8();

    @Message(id = 99, value = ""Received a ping of size other than 8"")
    String invalidPingSize();

    @Message(id = 100, value = ""stream id must be zero for frame type %s"")
    String streamIdMustBeZeroForFrameType(int frameType);

    @Message(id = 101, value = ""stream id must not be zero for frame type %s"")
    String streamIdMustNotBeZeroForFrameType(int frameType);

    @Message(id = 102, value = ""RST_STREAM received for idle stream"")
    String rstStreamReceivedForIdleStream();

    @Message(id = 103, value = ""Http2 stream was reset"")
    IOException http2StreamWasReset();

    @Message(id = 104, value = ""Incorrect HTTP2 preface"")
    IOException incorrectHttp2Preface();

    @Message(id = 105, value = ""HTTP2 frame to large"")
    IOException http2FrameTooLarge();

    @Message(id = 106, value = ""HTTP2 continuation frame received without a corresponding headers or push promise frame"")
    IOException http2ContinuationFrameNotExpected();

    //@Message(id = 107, value = ""Huffman encoded value in HPACK headers did not end with EOS padding"")
    //HpackException huffmanEncodedHpackValueDidNotEndWithEOS();

    //@Message(id = 108, value = ""HPACK variable length integer encoded over too many octects, max is %s"")
    //HpackException integerEncodedOverTooManyOctets(int maxIntegerOctets);

    //@Message(id = 109, value = ""Zero is not a valid header table index"")
    //HpackException zeroNotValidHeaderTableIndex();


    @Message(id = 110, value = ""Cannot send 100-Continue, getResponseChannel() has already been called"")
    IOException cannotSendContinueResponse();

    @Message(id = 111, value = ""Parser did not make progress"")
    IOException parserDidNotMakeProgress();

    @Message(id = 112, value = ""Only client side can call createStream, if you wish to send a PUSH_PROMISE frame use createPushPromiseStream instead"")
    IOException headersStreamCanOnlyBeCreatedByClient();

    @Message(id = 114, value = ""Invalid IP access control rule %s. Format is: [ip-match] allow|deny"")
    IllegalArgumentException invalidAclRule(String rule);
}
"
"core/src/main/java/io/undertow/server/Connectors.java:[43,314]:Connectors","public class Connectors {


    /**
     * Flattens the exchange cookie map into the response header map. This should be called by a
     * connector just before the response is started.
     *
     * @param exchange The server exchange
     */
    public static void flattenCookies(final HttpServerExchange exchange) {
        Map<String, Cookie> cookies = exchange.getResponseCookiesInternal();
        if (cookies != null) {
            for (Map.Entry<String, Cookie> entry : cookies.entrySet()) {
                exchange.getResponseHeaders().add(Headers.SET_COOKIE, getCookieString(entry.getValue()));
            }
        }
    }

    /**
     * Attached buffered data to the exchange. The will generally be used to allow data to be re-read.
     *
     * @param exchange The HTTP server exchange
     * @param buffers  The buffers to attach
     */
    public static void ungetRequestBytes(final HttpServerExchange exchange, Pooled<ByteBuffer>... buffers) {
        Pooled<ByteBuffer>[] existing = exchange.getAttachment(HttpServerExchange.BUFFERED_REQUEST_DATA);
        Pooled<ByteBuffer>[] newArray;
        if (existing == null) {
            newArray = new Pooled[buffers.length];
            System.arraycopy(buffers, 0, newArray, 0, buffers.length);
        } else {
            newArray = new Pooled[existing.length + buffers.length];
            System.arraycopy(existing, 0, newArray, 0, existing.length);
            System.arraycopy(buffers, 0, newArray, existing.length, buffers.length);
        }
        exchange.putAttachment(HttpServerExchange.BUFFERED_REQUEST_DATA, newArray); //todo: force some kind of wakeup?
        exchange.addExchangeCompleteListener(new ExchangeCompletionListener() {
            @Override
            public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener) {
                Pooled<ByteBuffer>[] bufs = exchange.getAttachment(HttpServerExchange.BUFFERED_REQUEST_DATA);
                if (bufs != null) {
                    for (Pooled<ByteBuffer> i : bufs) {
                        if(i != null) {
                            i.free();
                        }
                    }
                }
                nextListener.proceed();
            }
        });
    }

    public static void terminateRequest(final HttpServerExchange exchange) {
        exchange.terminateRequest();
    }

    public static void terminateResponse(final HttpServerExchange exchange) {
        exchange.terminateResponse();
    }

    private static String getCookieString(final Cookie cookie) {
        switch (cookie.getVersion()) {
            case 0:
                return addVersion0ResponseCookieToExchange(cookie);
            case 1:
            default:
                return addVersion1ResponseCookieToExchange(cookie);
        }
    }

    public static void setRequestStartTime(HttpServerExchange exchange) {
        exchange.setRequestStartTime(System.nanoTime());
    }

    private static String addVersion0ResponseCookieToExchange(final Cookie cookie) {
        final StringBuilder header = new StringBuilder(cookie.getName());
        header.append(""="");
        header.append(cookie.getValue());

        if (cookie.getPath() != null) {
            header.append(""; path="");
            header.append(cookie.getPath());
        }
        if (cookie.getDomain() != null) {
            header.append(""; domain="");
            header.append(cookie.getDomain());
        }
        if (cookie.isSecure()) {
            header.append(""; secure"");
        }
        if (cookie.isHttpOnly()) {
            header.append(""; HttpOnly"");
        }
        if (cookie.getExpires() != null) {
            header.append(""; Expires="");
            header.append(DateUtils.toOldCookieDateString(cookie.getExpires()));
        } else if (cookie.getMaxAge() != null) {
            if (cookie.getMaxAge() >= 0) {
                header.append(""; Max-Age="");
                header.append(cookie.getMaxAge());
            }
            if (cookie.getMaxAge() == 0) {
                Date expires = new Date();
                expires.setTime(0);
                header.append(""; Expires="");
                header.append(DateUtils.toOldCookieDateString(expires));
            } else if (cookie.getMaxAge() > 0) {
                Date expires = new Date();
                expires.setTime(expires.getTime() + cookie.getMaxAge() * 1000L);
                header.append(""; Expires="");
                header.append(DateUtils.toOldCookieDateString(expires));
            }
        }
        return header.toString();

    }

    private static String addVersion1ResponseCookieToExchange(final Cookie cookie) {

        final StringBuilder header = new StringBuilder(cookie.getName());
        header.append(""="");
        header.append(cookie.getValue());
        header.append(""; Version=1"");
        if (cookie.getPath() != null) {
            header.append(""; Path="");
            header.append(cookie.getPath());
        }
        if (cookie.getDomain() != null) {
            header.append(""; Domain="");
            header.append(cookie.getDomain());
        }
        if (cookie.isDiscard()) {
            header.append(""; Discard"");
        }
        if (cookie.isSecure()) {
            header.append(""; Secure"");
        }
        if (cookie.isHttpOnly()) {
            header.append(""; HttpOnly"");
        }
        if (cookie.getMaxAge() != null) {
            if (cookie.getMaxAge() >= 0) {
                header.append(""; Max-Age="");
                header.append(cookie.getMaxAge());
            }
        }
        if (cookie.getExpires() != null) {
            header.append(""; Expires="");
            header.append(DateUtils.toDateString(cookie.getExpires()));
        }
        return header.toString();
    }

    public static void executeRootHandler(final HttpHandler handler, final HttpServerExchange exchange) {
        try {
            exchange.setInCall(true);
            handler.handleRequest(exchange);
            exchange.setInCall(false);
            boolean resumed = exchange.runResumeReadWrite();
            if (exchange.isDispatched()) {
                if (resumed) {
                    throw new RuntimeException(""resumed and dispatched"");
                }
                final Runnable dispatchTask = exchange.getDispatchTask();
                Executor executor = exchange.getDispatchExecutor();
                exchange.setDispatchExecutor(null);
                exchange.unDispatch();
                if (dispatchTask != null) {
                    executor = executor == null ? exchange.getConnection().getWorker() : executor;
                    executor.execute(dispatchTask);
                }
            } else if (!resumed) {
                exchange.endExchange();
            }
        } catch (Throwable t) {
            exchange.setInCall(false);
            if (!exchange.isResponseStarted()) {
                exchange.setResponseCode(StatusCodes.INTERNAL_SERVER_ERROR);
            }
            UndertowLogger.REQUEST_LOGGER.errorf(t, ""Undertow request failed %s"", exchange);
            exchange.endExchange();
        }
    }


    /**
     * Sets the request path and query parameters, decoding to the requested charset.
     *
     * @param exchange    The exchange
     * @param encodedPath        The encoded path
     * @param charset     The charset
     */
    public static void setExchangeRequestPath(final HttpServerExchange exchange, final String encodedPath, final String charset, boolean decode, final boolean allowEncodedSlash, StringBuilder decodeBuffer) {
        boolean requiresDecode = false;
        for (int i = 0; i < encodedPath.length(); ++i) {
            char c = encodedPath.charAt(i);
            if (c == '?') {
                String part;
                String encodedPart = encodedPath.substring(0, i);
                if (requiresDecode) {
                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
                } else {
                    part = encodedPart;
                }
                exchange.setRequestPath(part);
                exchange.setRelativePath(part);
                exchange.setRequestURI(encodedPart);
                final String qs = encodedPath.substring(i + 1);
                exchange.setQueryString(qs);
                URLUtils.parseQueryString(qs, exchange, charset, decode);
                return;
            } else if(c == ';') {
                String part;
                String encodedPart = encodedPath.substring(0, i);
                if (requiresDecode) {
                    part = URLUtils.decode(encodedPart, charset, allowEncodedSlash, decodeBuffer);
                } else {
                    part = encodedPart;
                }
                exchange.setRequestPath(part);
                exchange.setRelativePath(part);
                for(int j = i; j < encodedPath.length(); ++j) {
                    if (encodedPath.charAt(j) == '?') {
                        exchange.setRequestURI(encodedPath.substring(0, j));
                        String pathParams = encodedPath.substring(i + 1, j);
                        URLUtils.parsePathParms(pathParams, exchange, charset, decode);
                        String qs = encodedPath.substring(j + 1);
                        exchange.setQueryString(qs);
                        URLUtils.parseQueryString(qs, exchange, charset, decode);
                        return;
                    }
                }
                exchange.setRequestURI(encodedPath);
                URLUtils.parsePathParms(encodedPath.substring(i + 1), exchange, charset, decode);
                return;
            } else if(c == '%' || c == '+') {
                requiresDecode = true;
            }
        }

        String part;
        if (requiresDecode) {
            part = URLUtils.decode(encodedPath, charset, allowEncodedSlash, decodeBuffer);
        } else {
            part = encodedPath;
        }
        exchange.setRequestPath(part);
        exchange.setRelativePath(part);
        exchange.setRequestURI(encodedPath);
    }


    /**
     * Returns the existing request channel, if it exists. Otherwise returns null
     *
     * @param exchange The http server exchange
     */
    public static StreamSourceChannel getExistingRequestChannel(final HttpServerExchange exchange) {
        return exchange.requestChannel;
    }

    public static boolean isEntityBodyAllowed(HttpServerExchange exchange){
        int code = exchange.getResponseCode();
        if(code >= 100 && code < 200) {
            return false;
        }
        if(code == 204 || code == 304) {
            return false;
        }
        return true;
    }
}
"
"core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java:[100,239]:handleEvent","    public void handleEvent(final StreamSourceChannel channel) {
        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {
            safeClose(connection);
            channel.suspendReads();
            return;
        }
        Pooled<ByteBuffer> existing = connection.getExtraBytes();

        final Pooled<ByteBuffer> pooled = existing == null ? connection.getBufferPool().allocate() : existing;
        final ByteBuffer buffer = pooled.getResource();
        boolean free = true;
        boolean bytesRead = false;
        try {
            int res;
            do {
                if (existing == null) {
                    buffer.clear();
                    try {
                        res = channel.read(buffer);
                    } catch (IOException e) {
                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
                        safeClose(connection);
                        return;
                    }
                } else {
                    res = buffer.remaining();
                }
                if (res == 0) {

                    if(bytesRead && parseTimeoutUpdater != null) {
                        parseTimeoutUpdater.failedParse();
                    }
                    if (!channel.isReadResumed()) {
                        channel.getReadSetter().set(this);
                        channel.resumeReads();
                    }
                    return;
                }
                if (res == -1) {
                    try {
                        channel.shutdownReads();
                        final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();
                        responseChannel.shutdownWrites();
                        safeClose(connection);
                    } catch (IOException e) {
                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
                        // fuck it, it's all ruined
                        safeClose(connection);
                        return;
                    }
                    return;
                }
                bytesRead = true;
                //TODO: we need to handle parse errors
                if (existing != null) {
                    existing = null;
                    connection.setExtraBytes(null);
                } else {
                    buffer.flip();
                }
                int begin = buffer.remaining();
                parser.parse(buffer, state, httpServerExchange);

                read += begin - buffer.remaining();
                if (buffer.hasRemaining()) {
                    free = false;
                    connection.setExtraBytes(pooled);
                }
                if (read > maxRequestSize) {
                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);
                    safeClose(connection);
                    return;
                }
            } while (!state.isComplete());

            if(parseTimeoutUpdater != null) {
                parseTimeoutUpdater.requestStarted();
            }
            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {
                if (state.prefix == AjpRequestParser.CPING) {
                    UndertowLogger.REQUEST_LOGGER.debug(""Received CPING, sending CPONG"");
                    handleCPing();
                } else if (state.prefix == AjpRequestParser.CPONG) {
                    UndertowLogger.REQUEST_LOGGER.debug(""Received CPONG, starting next request"");
                    state = new AjpRequestParseState();
                    channel.getReadSetter().set(this);
                    channel.resumeReads();
                } else {
                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);
                    safeClose(connection);
                }
                return;
            }

            // we remove ourselves as the read listener from the channel;
            // if the http handler doesn't set any then reads will suspend, which is the right thing to do
            channel.getReadSetter().set(null);
            channel.suspendReads();

            final HttpServerExchange httpServerExchange = this.httpServerExchange;
            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {
                @Override
                public void handleEvent(AjpServerResponseConduit channel) {
                    Connectors.terminateResponse(httpServerExchange);
                }
            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));
            connection.getChannel().getSinkChannel().setConduit(responseConduit);
            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));
            //we need to set the write ready handler. This allows the response conduit to wrap it
            responseConduit.setWriteReadyHandler(writeReadyHandler);

            try {
                connection.setSSLSessionInfo(state.createSslSessionInfo());
                httpServerExchange.setSourceAddress(state.createPeerAddress());
                httpServerExchange.setDestinationAddress(state.createDestinationAddress());
                if(scheme != null) {
                    httpServerExchange.setRequestScheme(scheme);
                }
                state = null;
                this.httpServerExchange = null;
                httpServerExchange.setPersistent(true);

                if(recordRequestStartTime) {
                    Connectors.setRequestStartTime(httpServerExchange);
                }
                connection.setCurrentExchange(httpServerExchange);
                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);

            } catch (Throwable t) {
                //TODO: we should attempt to return a 500 status code in this situation
                UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);
                safeClose(connection);
            }
        } catch (Exception e) {
            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(e);
            safeClose(connection);
        } finally {
            if (free) pooled.free();
        }
    }
"
"core/src/main/java/io/undertow/util/Methods.java:[27,92]:Methods","public final class Methods {

    private Methods() {
    }

    public static final String OPTIONS_STRING = ""OPTIONS"";
    public static final String GET_STRING = ""GET"";
    public static final String HEAD_STRING = ""HEAD"";
    public static final String POST_STRING = ""POST"";
    public static final String PUT_STRING = ""PUT"";
    public static final String DELETE_STRING = ""DELETE"";
    public static final String TRACE_STRING = ""TRACE"";
    public static final String CONNECT_STRING = ""CONNECT"";
    public static final String PROPFIND_STRING = ""PROPFIND"";
    public static final String PROPPATCH_STRING = ""PROPPATCH"";
    public static final String MKCOL_STRING = ""MKCOL"";
    public static final String COPY_STRING = ""COPY"";
    public static final String MOVE_STRING = ""MOVE"";
    public static final String LOCK_STRING = ""LOCK"";
    public static final String UNLOCK_STRING = ""UNLOCK"";
    public static final String ACL_STRING = ""ACL"";
    public static final String REPORT_STRING = ""REPORT"";
    public static final String VERSION_CONTROL_STRING = ""VERSION-CONTROL"";
    public static final String CHECKIN_STRING = ""CHECKIN"";
    public static final String CHECKOUT_STRING = ""CHECKOUT"";
    public static final String UNCHECKOUT_STRING = ""UNCHECKOUT"";
    public static final String SEARCH_STRING = ""SEARCH"";
    public static final String MKWORKSPACE_STRING = ""MKWORKSPACE"";
    public static final String UPDATE_STRING = ""UPDATE"";
    public static final String LABEL_STRING = ""LABEL"";
    public static final String MERGE_STRING = ""MERGE"";
    public static final String BASELINE_CONTROL_STRING = ""BASELINE_CONTROL"";
    public static final String MKACTIVITY_STRING = ""MKACTIVITY"";


    public static final HttpString OPTIONS = new HttpString(OPTIONS_STRING);
    public static final HttpString GET = new HttpString(GET_STRING);
    public static final HttpString HEAD = new HttpString(HEAD_STRING);
    public static final HttpString POST = new HttpString(POST_STRING);
    public static final HttpString PUT = new HttpString(PUT_STRING);
    public static final HttpString DELETE = new HttpString(DELETE_STRING);
    public static final HttpString TRACE = new HttpString(TRACE_STRING);
    public static final HttpString CONNECT = new HttpString(CONNECT_STRING);
    public static final HttpString PROPFIND =new HttpString(PROPFIND_STRING);
    public static final HttpString PROPPATCH =new HttpString(PROPPATCH_STRING);
    public static final HttpString MKCOL =new HttpString(MKCOL_STRING);
    public static final HttpString COPY =new HttpString(COPY_STRING);
    public static final HttpString MOVE =new HttpString(MOVE_STRING);
    public static final HttpString LOCK =new HttpString(LOCK_STRING);
    public static final HttpString UNLOCK =new HttpString(UNLOCK_STRING);
    public static final HttpString ACL =new HttpString(ACL_STRING);
    public static final HttpString REPORT =new HttpString(REPORT_STRING);
    public static final HttpString VERSION_CONTROL =new HttpString(VERSION_CONTROL_STRING);
    public static final HttpString CHECKIN =new HttpString(CHECKIN_STRING);
    public static final HttpString CHECKOUT =new HttpString(CHECKOUT_STRING);
    public static final HttpString UNCHECKOUT =new HttpString(UNCHECKOUT_STRING);
    public static final HttpString SEARCH =new HttpString(SEARCH_STRING);
    public static final HttpString MKWORKSPACE =new HttpString(MKWORKSPACE_STRING);
    public static final HttpString UPDATE =new HttpString(UPDATE_STRING);
    public static final HttpString LABEL =new HttpString(LABEL_STRING);
    public static final HttpString MERGE =new HttpString(MERGE_STRING);
    public static final HttpString BASELINE_CONTROL =new HttpString(BASELINE_CONTROL_STRING);
    public static final HttpString MKACTIVITY =new HttpString(MKACTIVITY_STRING);


}
"
"core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java:[155,843]:HttpRequestParser","public abstract class HttpRequestParser {

    private static final byte[] HTTP;
    public static final int HTTP_LENGTH;

    private final int maxParameters;
    private final int maxHeaders;
    private final boolean allowEncodedSlash;
    private final boolean decode;
    private final String charset;

    static {
        try {
            HTTP = ""HTTP/1."".getBytes(""ASCII"");
            HTTP_LENGTH = HTTP.length;
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public HttpRequestParser(OptionMap options) {
        maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, 1000);
        maxHeaders = options.get(UndertowOptions.MAX_HEADERS, 200);
        allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
        decode = options.get(UndertowOptions.DECODE_URL, true);
        charset = options.get(UndertowOptions.URL_CHARSET, ""UTF-8"");
    }

    public static final HttpRequestParser instance(final OptionMap options) {
        try {
            final Class<?> cls = Class.forName(HttpRequestParser.class.getName() + ""$$generated"", false, HttpRequestParser.class.getClassLoader());

            Constructor<?> ctor = cls.getConstructor(OptionMap.class);
            return (HttpRequestParser) ctor.newInstance(options);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    public void handle(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder) {
        if (currentState.state == ParseState.VERB) {
            //fast path, we assume that it will parse fully so we avoid all the if statements

            //fast path HTTP GET requests, basically just assume all requests are get
            //and fall out to the state machine if it is not
            final int position = buffer.position();
            if (buffer.remaining() > 3
                    && buffer.get(position) == 'G'
                    && buffer.get(position + 1) == 'E'
                    && buffer.get(position + 2) == 'T'
                    && buffer.get(position + 3) == ' ') {
                buffer.position(position + 4);
                builder.setRequestMethod(Methods.GET);
                currentState.state = ParseState.PATH;
            } else {
                handleHttpVerb(buffer, currentState, builder);
            }
            handlePath(buffer, currentState, builder);
            boolean failed = false;
            if (buffer.remaining() > HTTP_LENGTH + 3) {
                int pos = buffer.position();
                for (int i = 0; i < HTTP_LENGTH; ++i) {
                    if (HTTP[i] != buffer.get(pos + i)) {
                        failed = true;
                        break;
                    }
                }
                if (!failed) {
                    final byte b = buffer.get(pos + HTTP_LENGTH);
                    final byte b2 = buffer.get(pos + HTTP_LENGTH + 1);
                    final byte b3 = buffer.get(pos + HTTP_LENGTH + 2);
                    if (b2 == '\r' && b3 == '\n') {
                        if (b == '1') {
                            builder.setProtocol(Protocols.HTTP_1_1);
                            buffer.position(pos + HTTP_LENGTH + 3);
                            currentState.state = ParseState.HEADER;
                        } else if (b == '0') {
                            builder.setProtocol(Protocols.HTTP_1_0);
                            buffer.position(pos + HTTP_LENGTH + 3);
                            currentState.state = ParseState.HEADER;
                        } else {
                            failed = true;
                        }
                    } else {
                        failed = true;
                    }
                }
            } else {
                failed = true;
            }
            if (failed) {
                handleHttpVersion(buffer, currentState, builder);
                handleAfterVersion(buffer, currentState);
            }

            while (currentState.state != ParseState.PARSE_COMPLETE && buffer.hasRemaining()) {
                handleHeader(buffer, currentState, builder);
                if (currentState.state == ParseState.HEADER_VALUE) {
                    handleHeaderValue(buffer, currentState, builder);
                }
            }
            return;
        }
        handleStateful(buffer, currentState, builder);
    }

    private void handleStateful(ByteBuffer buffer, ParseState currentState, HttpServerExchange builder) {
        if (currentState.state == ParseState.PATH) {
            handlePath(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.QUERY_PARAMETERS) {
            handleQueryParameters(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.PATH_PARAMETERS) {
            handlePathParameters(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }

        if (currentState.state == ParseState.VERSION) {
            handleHttpVersion(buffer, currentState, builder);
            if (!buffer.hasRemaining()) {
                return;
            }
        }
        if (currentState.state == ParseState.AFTER_VERSION) {
            handleAfterVersion(buffer, currentState);
            if (!buffer.hasRemaining()) {
                return;
            }
        }
        while (currentState.state != ParseState.PARSE_COMPLETE) {
            if (currentState.state == ParseState.HEADER) {
                handleHeader(buffer, currentState, builder);
                if (!buffer.hasRemaining()) {
                    return;
                }
            }
            if (currentState.state == ParseState.HEADER_VALUE) {
                handleHeaderValue(buffer, currentState, builder);
                if (!buffer.hasRemaining()) {
                    return;
                }
            }
        }
    }


    abstract void handleHttpVerb(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    abstract void handleHttpVersion(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    abstract void handleHeader(ByteBuffer buffer, final ParseState currentState, final HttpServerExchange builder);

    /**
     * The parse states for parsing the path.
     */
    private static final int START = 0;
    private static final int FIRST_COLON = 1;
    private static final int FIRST_SLASH = 2;
    private static final int SECOND_SLASH = 3;
    private static final int IN_PATH = 4;
    private static final int HOST_DONE = 5;

    /**
     * Parses a path value
     *
     * @param buffer   The buffer
     * @param state    The current state
     * @param exchange The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handlePath(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int parseState = state.parseState;
        int canonicalPathStart = state.pos;
        boolean urlDecodeRequired = state.urlDecodeRequired;

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t') {
                if (stringBuilder.length() != 0) {
                    final String path = stringBuilder.toString();
                    if (parseState < HOST_DONE) {
                        String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
                        exchange.setRequestPath(decodedPath);
                        exchange.setRelativePath(decodedPath);
                        exchange.setRequestURI(path);
                    } else {
                        handleFullUrl(state, exchange, canonicalPathStart, urlDecodeRequired, path);
                    }
                    exchange.setQueryString("""");
                    state.state = ParseState.VERSION;
                    state.stringBuilder.setLength(0);
                    state.parseState = 0;
                    state.pos = 0;
                    state.urlDecodeRequired = false;
                    return;
                }
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else if (next == '?' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginQueryParameters(buffer, state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                return;
            } else if (next == ';' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginPathParameters(state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                handlePathParameters(buffer, state, exchange);
                return;
            } else {

                if (decode && (next == '+' || next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                } else if (next == ':' && parseState == START) {
                    parseState = FIRST_COLON;
                } else if (next == '/' && parseState == FIRST_COLON) {
                    parseState = FIRST_SLASH;
                } else if (next == '/' && parseState == FIRST_SLASH) {
                    parseState = SECOND_SLASH;
                } else if (next == '/' && parseState == SECOND_SLASH) {
                    parseState = HOST_DONE;
                    canonicalPathStart = stringBuilder.length();
                } else if (parseState == FIRST_COLON || parseState == FIRST_SLASH) {
                    parseState = IN_PATH;
                } else if (next == '/' && parseState != HOST_DONE) {
                    parseState = IN_PATH;
                }
                stringBuilder.append(next);
            }

        }
        state.parseState = parseState;
        state.pos = canonicalPathStart;
        state.urlDecodeRequired = urlDecodeRequired;
    }

    private void beginPathParameters(ParseState state, HttpServerExchange exchange, StringBuilder stringBuilder, int parseState, int canonicalPathStart, boolean urlDecodeRequired) {
        final String path = stringBuilder.toString();
        if (parseState < HOST_DONE) {
            String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
            exchange.setRequestPath(decodedPath);
            exchange.setRelativePath(decodedPath);
            exchange.setRequestURI(path);
        } else {
            String thePath = path.substring(canonicalPathStart);
            exchange.setRequestPath(thePath);
            exchange.setRelativePath(thePath);
            exchange.setRequestURI(path, true);
        }
        state.state = ParseState.PATH_PARAMETERS;
        state.stringBuilder.setLength(0);
        state.parseState = 0;
        state.pos = 0;
        state.urlDecodeRequired = false;
    }

    private void beginQueryParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange, StringBuilder stringBuilder, int parseState, int canonicalPathStart, boolean urlDecodeRequired) {
        final String path = stringBuilder.toString();
        if (parseState < HOST_DONE) {
            String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
            exchange.setRequestPath(decodedPath);
            exchange.setRelativePath(decodedPath);
            exchange.setRequestURI(path, false);
        } else {
            handleFullUrl(state, exchange, canonicalPathStart, urlDecodeRequired, path);
        }
        state.state = ParseState.QUERY_PARAMETERS;
        state.stringBuilder.setLength(0);
        state.parseState = 0;
        state.pos = 0;
        state.urlDecodeRequired = false;
        handleQueryParameters(buffer, state, exchange);
    }

    private void handleFullUrl(ParseState state, HttpServerExchange exchange, int canonicalPathStart, boolean urlDecodeRequired, String path) {
        String thePath = decode(path.substring(canonicalPathStart), urlDecodeRequired, state, allowEncodedSlash);
        exchange.setRequestPath(thePath);
        exchange.setRelativePath(thePath);
        exchange.setRequestURI(path, true);
    }


    /**
     * Parses a path value
     *
     * @param buffer   The buffer
     * @param state    The current state
     * @param exchange The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handleQueryParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int queryParamPos = state.pos;
        int mapCount = state.mapCount;
        boolean urlDecodeRequired = state.urlDecodeRequired;
        String nextQueryParam = state.nextQueryParam;

        //so this is a bit funky, because it not only deals with parsing, but
        //also deals with URL decoding the query parameters as well, while also
        //maintaining a non-decoded version to use as the query string
        //In most cases these string will be the same, and as we do not want to
        //build up two separate strings we don't use encodedStringBuilder unless
        //we encounter an encoded character

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t') {
                final String queryString = stringBuilder.toString();
                exchange.setQueryString(queryString);
                if (nextQueryParam == null) {
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addQueryParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                } else {
                    exchange.addQueryParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                }
                state.state = ParseState.VERSION;
                state.stringBuilder.setLength(0);
                state.pos = 0;
                state.nextQueryParam = null;
                state.urlDecodeRequired = false;
                state.mapCount = 0;
                return;
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else {
                if (decode && (next == '+' || next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                } else if (next == '=' && nextQueryParam == null) {
                    nextQueryParam = decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true);
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&' && nextQueryParam == null) {
                    if (mapCount++ > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addQueryParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&') {
                    if (mapCount++ > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    exchange.addQueryParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                    nextQueryParam = null;
                }
                stringBuilder.append(next);

            }

        }
        state.pos = queryParamPos;
        state.nextQueryParam = nextQueryParam;
        state.urlDecodeRequired = urlDecodeRequired;
        state.mapCount = 0;
    }

    private String decode(final String value, boolean urlDecodeRequired, ParseState state, final boolean allowEncodedSlash) {
        if (urlDecodeRequired) {
            return URLUtils.decode(value, charset, allowEncodedSlash, state.decodeBuffer);
        } else {
            return value;
        }
    }


    final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int queryParamPos = state.pos;
        int mapCount = state.mapCount;
        boolean urlDecodeRequired = state.urlDecodeRequired;
        String nextQueryParam = state.nextQueryParam;

        //so this is a bit funky, because it not only deals with parsing, but
        //also deals with URL decoding the query parameters as well, while also
        //maintaining a non-decoded version to use as the query string
        //In most cases these string will be the same, and as we do not want to
        //build up two separate strings we don't use encodedStringBuilder unless
        //we encounter an encoded character

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t' || next == '?') {
                if (nextQueryParam == null) {
                    if (queryParamPos != stringBuilder.length()) {
                        exchange.addPathParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    }
                } else {
                    exchange.addPathParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                }
                exchange.setRequestURI(exchange.getRequestURI() + ';' + stringBuilder.toString(), state.parseState > HOST_DONE);
                state.stringBuilder.setLength(0);
                state.pos = 0;
                state.nextQueryParam = null;
                state.mapCount = 0;
                state.urlDecodeRequired = false;
                if (next == '?') {
                    state.state = ParseState.QUERY_PARAMETERS;
                    handleQueryParameters(buffer, state, exchange);
                } else {
                    state.state = ParseState.VERSION;
                }
                return;
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else {
                if (decode && (next == '+' || next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                }
                if (next == '=' && nextQueryParam == null) {
                    nextQueryParam = decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true);
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&' && nextQueryParam == null) {
                    if (mapCount++ > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }
                    exchange.addPathParam(decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true), """");
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                } else if (next == '&') {
                    if (mapCount++ > maxParameters) {
                        throw UndertowMessages.MESSAGES.tooManyQueryParameters(maxParameters);
                    }

                    exchange.addPathParam(nextQueryParam, decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true));
                    urlDecodeRequired = false;
                    queryParamPos = stringBuilder.length() + 1;
                    nextQueryParam = null;
                }
                stringBuilder.append(next);

            }

        }
        state.pos = queryParamPos;
        state.nextQueryParam = nextQueryParam;
        state.mapCount = 0;
        state.urlDecodeRequired = urlDecodeRequired;
    }


    /**
     * The parse states for parsing heading values
     */
    private static final int NORMAL = 0;
    private static final int WHITESPACE = 1;
    private static final int BEGIN_LINE_END = 2;
    private static final int LINE_END = 3;
    private static final int AWAIT_DATA_END = 4;

    /**
     * Parses a header value. This is called from the generated bytecode.
     *
     * @param buffer  The buffer
     * @param state   The current state
     * @param builder The exchange builder
     * @return The number of bytes remaining
     */
    @SuppressWarnings(""unused"")
    final void handleHeaderValue(ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
        HttpString headerName = state.nextHeader;
        StringBuilder stringBuilder = state.stringBuilder;
        HashMap<HttpString, String> headerValuesCache = state.headerValuesCache;
        if (stringBuilder.length() == 0) {
            String existing = headerValuesCache.get(headerName);
            if (existing != null) {
                if (handleCachedHeader(existing, buffer, state, builder)) {
                    return;
                }
            }
        }

        handleHeaderValueCacheMiss(buffer, state, builder, headerName, headerValuesCache, stringBuilder);
    }

    private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, HttpServerExchange builder, HttpString headerName, HashMap<HttpString, String> headerValuesCache, StringBuilder stringBuilder) {

        int parseState = state.parseState;
        while (buffer.hasRemaining() && parseState == NORMAL) {
            final byte next = buffer.get();
            if (next == '\r') {
                parseState = BEGIN_LINE_END;
            } else if (next == '\n') {
                parseState = LINE_END;
            } else if (next == ' ' || next == '\t') {
                parseState = WHITESPACE;
            } else {
                stringBuilder.append((char) (next & 0xFF));
            }
        }

        while (buffer.hasRemaining()) {
            final byte next = buffer.get();
            switch (parseState) {
                case NORMAL: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                        parseState = WHITESPACE;
                    } else {
                        stringBuilder.append((char) (next & 0xFF));
                    }
                    break;
                }
                case WHITESPACE: {
                    if (next == '\r') {
                        parseState = BEGIN_LINE_END;
                    } else if (next == '\n') {
                        parseState = LINE_END;
                    } else if (next == ' ' || next == '\t') {
                    } else {
                        if (stringBuilder.length() > 0) {
                            stringBuilder.append(' ');
                        }
                        stringBuilder.append((char) (next & 0xFF));
                        parseState = NORMAL;
                    }
                    break;
                }
                case LINE_END:
                case BEGIN_LINE_END: {
                    if (next == '\n' && parseState == BEGIN_LINE_END) {
                        parseState = LINE_END;
                    } else if (next == '\t' ||
                            next == ' ') {
                        //this is a continuation
                        parseState = WHITESPACE;
                    } else {
                        //we have a header
                        String headerValue = stringBuilder.toString();


                        if (state.mapCount++ > maxHeaders) {
                            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
                        }
                        //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
                        builder.getRequestHeaders().add(headerName, headerValue);
                        if(headerValuesCache.size() < maxHeaders) {
                            //we have a limit on how many we can cache
                            //to prevent memory filling and hash collision attacks
                            headerValuesCache.put(headerName, headerValue);
                        }

                        state.nextHeader = null;

                        state.leftOver = next;
                        state.stringBuilder.setLength(0);
                        if (next == '\r') {
                            parseState = AWAIT_DATA_END;
                        } else if (next == '\n') {
                            state.state = ParseState.PARSE_COMPLETE;
                            return;
                        } else {
                            state.state = ParseState.HEADER;
                            state.parseState = 0;
                            return;
                        }
                    }
                    break;
                }
                case AWAIT_DATA_END: {
                    state.state = ParseState.PARSE_COMPLETE;
                    return;
                }
            }
        }
        //we only write to the state if we did not finish parsing
        state.parseState = parseState;
    }

    protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseState state, HttpServerExchange builder) {
        int pos = buffer.position();
        while (pos < buffer.limit() && buffer.get(pos) == ' ') {
            pos++;
        }
        if (existing.length() + 3 + pos > buffer.limit()) {
            return false;
        }
        int i = 0;
        while (i < existing.length()) {
            byte b = buffer.get(pos + i);
            if (b != existing.charAt(i)) {
                return false;
            }
            ++i;
        }
        if (buffer.get(pos + i++) != '\r') {
            return false;
        }
        if (buffer.get(pos + i++) != '\n') {
            return false;
        }
        int next = buffer.get(pos + i);
        if (next == '\t' || next == ' ') {
            //continuation
            return false;
        }
        buffer.position(pos + i);
        if (state.mapCount++ > maxHeaders) {
            throw UndertowMessages.MESSAGES.tooManyHeaders(maxHeaders);
        }
        //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
        builder.getRequestHeaders().add(state.nextHeader, existing);

        state.nextHeader = null;

        state.state = ParseState.HEADER;
        state.parseState = 0;
        return true;
    }

    protected void handleAfterVersion(ByteBuffer buffer, ParseState state) {
        boolean newLine = state.leftOver == '\n';
        while (buffer.hasRemaining()) {
            final byte next = buffer.get();
            if (newLine) {
                if (next == '\n') {
                    state.state = ParseState.PARSE_COMPLETE;
                    return;
                } else {
                    state.state = ParseState.HEADER;
                    state.leftOver = next;
                    return;
                }
            } else {
                if (next == '\n') {
                    newLine = true;
                } else if (next != '\r' && next != ' ' && next != '\t') {
                    state.state = ParseState.HEADER;
                    state.leftOver = next;
                    return;
                } else {
                    throw UndertowMessages.MESSAGES.badRequest();
                }
            }
        }
        if (newLine) {
            state.leftOver = '\n';
        }
    }

    /**
     * This is a bit of hack to enable the parser to get access to the HttpString's that are sorted
     * in the static fields of the relevant classes. This means that in most cases a HttpString comparison
     * will take the fast path == route, as they will be the same object
     *
     * @return
     */
    protected static Map<String, HttpString> httpStrings() {
        final Map<String, HttpString> results = new HashMap<>();
        final Class[] classs = {Headers.class, Methods.class, Protocols.class};

        for (Class<?> c : classs) {
            for (Field field : c.getDeclaredFields()) {
                if (field.getType().equals(HttpString.class)) {
                    field.setAccessible(true);
                    HttpString result = null;
                    try {
                        result = (HttpString) field.get(null);
                        results.put(result.toString(), result);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
        return results;

    }

}
"
"core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java:[338,399]:handlePath","    final void handlePath(ByteBuffer buffer, ParseState state, HttpServerExchange exchange) {
        StringBuilder stringBuilder = state.stringBuilder;
        int parseState = state.parseState;
        int canonicalPathStart = state.pos;
        boolean urlDecodeRequired = state.urlDecodeRequired;

        while (buffer.hasRemaining()) {
            char next = (char) (buffer.get() & 0xFF);
            if (next == ' ' || next == '\t') {
                if (stringBuilder.length() != 0) {
                    final String path = stringBuilder.toString();
                    if (parseState < HOST_DONE) {
                        String decodedPath = decode(path, urlDecodeRequired, state, allowEncodedSlash);
                        exchange.setRequestPath(decodedPath);
                        exchange.setRelativePath(decodedPath);
                        exchange.setRequestURI(path);
                    } else {
                        handleFullUrl(state, exchange, canonicalPathStart, urlDecodeRequired, path);
                    }
                    exchange.setQueryString("""");
                    state.state = ParseState.VERSION;
                    state.stringBuilder.setLength(0);
                    state.parseState = 0;
                    state.pos = 0;
                    state.urlDecodeRequired = false;
                    return;
                }
            } else if (next == '\r' || next == '\n') {
                throw UndertowMessages.MESSAGES.failedToParsePath();
            } else if (next == '?' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginQueryParameters(buffer, state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                return;
            } else if (next == ';' && (parseState == START || parseState == HOST_DONE || parseState == IN_PATH)) {
                beginPathParameters(state, exchange, stringBuilder, parseState, canonicalPathStart, urlDecodeRequired);
                handlePathParameters(buffer, state, exchange);
                return;
            } else {

                if (decode && (next == '+' || next == '%' || next > 127)) {
                    urlDecodeRequired = true;
                } else if (next == ':' && parseState == START) {
                    parseState = FIRST_COLON;
                } else if (next == '/' && parseState == FIRST_COLON) {
                    parseState = FIRST_SLASH;
                } else if (next == '/' && parseState == FIRST_SLASH) {
                    parseState = SECOND_SLASH;
                } else if (next == '/' && parseState == SECOND_SLASH) {
                    parseState = HOST_DONE;
                    canonicalPathStart = stringBuilder.length();
                } else if (parseState == FIRST_COLON || parseState == FIRST_SLASH) {
                    parseState = IN_PATH;
                } else if (next == '/' && parseState != HOST_DONE) {
                    parseState = IN_PATH;
                }
                stringBuilder.append(next);
            }

        }
        state.parseState = parseState;
        state.pos = canonicalPathStart;
        state.urlDecodeRequired = urlDecodeRequired;
    }
"
"core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java:[115,202]:handleEventWithNoRunningRequest","    public void handleEventWithNoRunningRequest(final ConduitStreamSourceChannel channel) {
        Pooled<ByteBuffer> existing = connection.getExtraBytes();
        if ((existing == null && connection.getOriginalSourceConduit().isReadShutdown()) || connection.getOriginalSinkConduit().isWriteShutdown()) {
            IoUtils.safeClose(connection);
            channel.suspendReads();
            return;
        }

        final Pooled<ByteBuffer> pooled = existing == null ? connection.getBufferPool().allocate() : existing;
        final ByteBuffer buffer = pooled.getResource();
        boolean free = true;

        try {
            int res;
            boolean bytesRead = false;
            do {
                if (existing == null) {
                    buffer.clear();
                    try {
                        res = channel.read(buffer);
                    } catch (IOException e) {
                        UndertowLogger.REQUEST_IO_LOGGER.debug(""Error reading request"", e);
                        IoUtils.safeClose(connection);
                        return;
                    }
                } else {
                    res = buffer.remaining();
                }

                if (res <= 0) {
                    if(bytesRead && parseTimeoutUpdater != null) {
                        parseTimeoutUpdater.failedParse();
                    }
                    handleFailedRead(channel, res);
                    return;
                } else {
                    bytesRead = true;
                }
                if (existing != null) {
                    existing = null;
                    connection.setExtraBytes(null);
                } else {
                    buffer.flip();
                }
                int begin = buffer.remaining();
                parser.handle(buffer, state, httpServerExchange);
                if (buffer.hasRemaining()) {
                    free = false;
                    connection.setExtraBytes(pooled);
                }
                int total = read + (begin - buffer.remaining());
                read = total;
                if (read > maxRequestSize) {
                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);
                    IoUtils.safeClose(connection);
                    return;
                }
            } while (!state.isComplete());
            if(parseTimeoutUpdater != null) {
                parseTimeoutUpdater.requestStarted();
            }

            final HttpServerExchange httpServerExchange = this.httpServerExchange;
            httpServerExchange.setRequestScheme(connection.getSslSession() != null ? ""https"" : ""http"");
            this.httpServerExchange = null;
            requestStateUpdater.set(this, 1);

            if(!allowUnknownProtocols) {
                HttpString protocol = httpServerExchange.getProtocol();
                if(protocol != Protocols.HTTP_1_1 && protocol != Protocols.HTTP_1_0 && protocol != Protocols.HTTP_0_9) {
                    UndertowLogger.REQUEST_IO_LOGGER.debugf(""Closing connection from %s due to unknown protocol %s"", connection.getChannel().getPeerAddress(), protocol);
                    sendBadRequestAndClose(connection.getChannel(), new IOException());
                    return;
                }
            }
            HttpTransferEncoding.setupRequest(httpServerExchange);
            if (recordRequestStartTime) {
                Connectors.setRequestStartTime(httpServerExchange);
            }
            connection.setCurrentExchange(httpServerExchange);
            Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);
        } catch (Exception e) {
            sendBadRequestAndClose(connection.getChannel(), e);
            return;
        } finally {
            if (free) pooled.free();
        }
    }
"
